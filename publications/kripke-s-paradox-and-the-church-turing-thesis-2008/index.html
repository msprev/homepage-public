<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Kripke&rsquo;s paradox and the Church&ndash;Turing thesis</title>
                <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="viewport" content="width=device-width, initial-scale=1 minimal-ui">

        <meta name="description" content="">
        <meta name="keywords" content="">

        

        
        <meta name="twitter:card" content="summary">
        
        <meta name="twitter:site" content="@msprevak">
        <meta name="twitter:title" content="Kripke&#39;s paradox and the Church--Turing thesis : marksprevak.com">
        <meta name="twitter:creator" content="@msprevak">
        <meta name="twitter:description" content="">
        <meta name="twitter:image:src" content="">
        <meta name="twitter:domain" content="marksprevak.com">

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">




<link rel="stylesheet" href="http://marksprevak.com/css/stylesheet.min.css" />
<link rel="stylesheet" href="http://marksprevak.com/font-awesome/css/font-awesome.min.css">

<script type="text/javascript" src="http://marksprevak.com/scripts/jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="http://marksprevak.com/kube/js/kube.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <style type="text/css">
          .hidden {display:none;}
        </style>
        <script type="text/javascript">
          $('html').addClass('hidden');
          $(document).ready(function() {
            $('html').removeClass('hidden');
           });
         </script>


<title>Mark Sprevak</title>
<base href="http://marksprevak.com/">
<link rel="canonical" href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/">

<link href="https://fonts.googleapis.com/css?family=Roboto:400,700%7CLato:400,700" rel="stylesheet">

        
    </head>
    <body>

        <div class="wrapper">

            <div class="row" style="padding-bottom: 8px; padding-top: 0px; margin-bottom: 12px; border-bottom: 1px solid; border-color: rgba(0, 0, 0, 0.3);">
    <div class="show-sm col col-12">
            <div class="titlebar"><a href="http://marksprevak.com/">Mark&nbsp;Sprevak</a>
                <a href="#" data-component="toggleme" data-target="#navbar" style="float: right; color: rgba(0, 0, 0, 0.8);"><i class="kube-menu"></i></a>
            </div>
    </div>

    <div class="hide-sm col col-12">
            <div class="row">
                <div class="col col-3">
                    <div class="titlebar"><a href="http://marksprevak.com/">Mark&nbsp;Sprevak</a></div>
                </div>

                <div class="col col-9">
                    <ul class="unstyled">
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/teaching/" style="text-decoration: none; border-bottom: none;">Teaching</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/mscs/" style="text-decoration: none; border-bottom: none;">MSc research</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/phds/" style="text-decoration: none; border-bottom: none;">PhD research</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/cv/" style="text-decoration: none; border-bottom: none;">CV</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/outreach/" style="text-decoration: none; border-bottom: none;">Outreach</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/talks/" style="text-decoration: none; border-bottom: none;">Talks</a>
                        </li>
                        
                        
                        
                        <li style="float: right; margin-left: 20px;"  >
                            <a href="http://marksprevak.com/publications/" style="text-decoration: none; border-bottom: none;">Publications</a>
                        </li>
                        
                        
                        
                        
                    </ul>
                </div>
            </div>
    </div>

    <nav id="navbar" class="hide show-sm">
        <ul style="float: right; text-align:right; padding-right:5px;">
            
            
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/publications/" style="text-decoration: none; border-bottom: none;">Publications</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/talks/" style="text-decoration: none; border-bottom: none;">Talks</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/outreach/" style="text-decoration: none; border-bottom: none;">Outreach</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/cv/" style="text-decoration: none; border-bottom: none;">CV</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/phds/" style="text-decoration: none; border-bottom: none;">PhD research</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/mscs/" style="text-decoration: none; border-bottom: none;">MSc research</a>
            </li>
            
            
            
            <li style=""  >
                <a href="http://marksprevak.com/teaching/" style="text-decoration: none; border-bottom: none;">Teaching</a>
            </li>
            
            
        </ul>
    </nav>
</div>


            <div class="row gutters">
                <div class="col col-8">

                    <div style="padding-bottom: 30px;">
                        <div style="margin-bottom: 10px;">
                            <h1 style="margin-top: 0px; margin-bottom: 0px; color: black;">Kripke&rsquo;s paradox and the Church&ndash;Turing thesis</h1>
                            
                            <p class="muted" style="margin-top: 10px;">
                                
                                    2008  &nbsp;
                                
                                <em>Synthese</em>, 160: 285&#8211;295
                            </p>
                            <p class="small" style="margin-top: 10px;">
                                <span>Last updated 10 October 2006</span>
                                
                            </p>
                        </div>
                        <div class="hide-print">
                            
                            <a href="http://marksprevak.com/pdf/paper/Sprevak---Kripke%20and%20the%20Church-Turing%20Thesis.pdf" target="_blank" class="label badge outline focus upper"><span class="fa fa-file-pdf-o"></span>&nbsp;PDF</a>
                            &nbsp;&nbsp;
                            
                            
                            
                            <a href="http://dx.doi.org/10.1007/s11229-006-9120-2" target="_blank" class="label tag focus upper">doi&nbsp;<span style="font-size: 10px; padding-left: 1px;" class="fa fa-external-link"></span></a>
                            
                        </div>
                    </div>

                    <div class="hide-sm">
                        
                        <div class="article-style" style="margin-left: 30px; margin-right: 30px; margin-bottom: 30px;">
                            <p>Kripke (1982) presents a rule-following paradox in terms of what we meant by our past use of ‘plus’, but the same paradox can be applied to any other term in natural language. Many responses to the paradox concentrate on fixing determinate meaning for ‘plus’, or for a small class of other natural language terms. This raises a problem: how can these particular responses be generalised to the whole of natural language? In this paper, I propose a solution. I argue that if natural language is computable in a sense defined below, and the Church–Turing thesis is accepted, then this auxiliary problem can be solved.</p>

                        </div>
                        
                    </div>
                    <div class="show-sm">
                        
                            
                            <div class="hide-print" style="border-bottom: 0; margin-top: 5px; padding-bottom: 10px; padding-right: 20px; width:33%; float: left;">
                                <img src="http://marksprevak.com/img/pubs/synthese.jpg" alt="">
                            </div>
                            
                            <div class="muted smaller hide-print">
                                Abstract:
                            </div>
                            <div class="article-style" style="margin-bottom: 30px;">
                                <p>Kripke (1982) presents a rule-following paradox in terms of what we meant by our past use of ‘plus’, but the same paradox can be applied to any other term in natural language. Many responses to the paradox concentrate on fixing determinate meaning for ‘plus’, or for a small class of other natural language terms. This raises a problem: how can these particular responses be generalised to the whole of natural language? In this paper, I propose a solution. I argue that if natural language is computable in a sense defined below, and the Church–Turing thesis is accepted, then this auxiliary problem can be solved.</p>

                            </div>
                        
                    </div>

                    <div>
                        
                        <div class="show-sm">
                            
                                <h1 style="margin-top: 0px;" id="internal-mds-toc">Contents</h1>
                                <ul class="unstyled">
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#introduction"><span style="font-size: 14px;">1 &nbsp; Introduction</span></a>
                                        
                                    </li>
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-algorithm-reply"><span style="font-size: 14px;">2 &nbsp; The algorithm reply</span></a>
                                        
                                    </li>
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-computability-assumption"><span style="font-size: 14px;">3 &nbsp; The computability assumption</span></a>
                                        
                                    </li>
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-pay-off"><span style="font-size: 14px;">4 &nbsp; The pay-off</span></a>
                                        
                                    </li>
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#commitment-to-the-ctm"><span style="font-size: 14px;">5 &nbsp; Commitment to the CTM</span></a>
                                        
                                    </li>
                                    
                                    <li>
                                        
                                        <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#conclusion"><span style="font-size: 14px;">6 &nbsp; Conclusion</span></a>
                                        
                                    </li>
                                    
                                </ul>
                            
                            
                        </div>
                        <div class="article-style">
                            <div>
<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>I do not aim to solve Kripke’s rule-following problem in this paper. I address a related problem that should be a source of worry for respondents to Kripke. This problem is as follows. Kripke’s challenge about meaning is general: it can be applied to any term in natural language. However, many responses to his challenge are specific: they aim to fix meaning for particular terms or classes of terms. The problem that I address is how to extend these particular solutions to the entirety of natural language. I call this the ‘auxiliary problem’. The auxiliary problem, although not Kripke’s rule-following problem, is important nonetheless. Even if one managed to solve the rule-following problem for a proper subset of natural language – an incredibly hard task – the auxiliary problem would remain. The auxiliary problem has received little or no attention in the literature. In this paper, I describe the auxiliary problem, and I propose a solution. I argue that, provided natural language is computable in a certain sense defined below, a result in computation theory, the Church–Turing thesis, provides a solution.</p>
<p>Kripke’s challenge can be summarised as follows. Kripke’s sceptic asks what fact determined that you meant <em>plus</em> rather than <em>quus</em> in your past use of the term ‘plus’, where <em>quus</em> is a function just like the addition function for all sums below those you have already computed, but diverges for higher numbers. The same question, suitably modified, can be asked about any term in natural language. The sceptic’s challenge has generated a huge number of responses.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Some of the leading responses attempt to state a fact that fixes meaning. Such ‘straight’ replies tend to restrict attention to a few terms, or to certain kinds of terms. Solving the problem, even for these limited cases, would be a major achievement. However, even if success is granted, the problem remains of generalising the solution. If this cannot be done, then Kripke’s sceptic would be free to press her question for other terms.</p>
<p><span class="citation" data-cites="Maddy84">Maddy (1984)</span> and <span class="citation" data-cites="McGinn84">McGinn (1984)</span> argue that the sceptic’s challenge can be answered for proper names (e.g. ‘Cicero’) and natural kind terms (e.g. ‘water’) by Kripke’s own causal theory of reference. However, is not clear how the causal theory of reference could fix determinate meaning for terms that are neither proper names nor natural kind terms (e.g. ‘friend’, ‘scientist’). Even if Maddy and McGinn are correct about proper names and natural kind terms, it is not clear how their reply could be a general solution. <span class="citation" data-cites="Millikan90">Millikan (1990)</span> gives a different reply to the sceptic. She argues that terms that are associated in salient ways with our evolutionary history (e.g. ‘milk’, ‘danger’) have their meaning fixed by facts about that history. Again, even if correct, this has limited scope as a solution. Not all terms have distinctive associations with our evolutionary past. It is not clear, for example, how Millikan’s account could fix the meaning of terms associated with recent concepts such as ‘herbaceous border’ or ‘wicket keeper’. <span class="citation" data-cites="Fodor90f">Fodor (1990)</span> advocates yet another response to the sceptic. He argues that the meanings of predicates are fixed by asymmetric nomic relations that obtain between the tokening of a predicate, such as ‘… is a cow’, and the property that it names, <em>being a cow</em>. Again, whatever the merits of this solution, it is unlikely to succeed as a general account. For one thing, it requires a property to exist for every meaningful predicate: a meaning-constituting asymmetric nomic relation cannot obtain unless both predicate tokening and corresponding property exist. However, it is far from clear which properties exist, and whether there are enough properties for each meaningful predicate. Even if Fodor is correct about some terms, there may be other terms without corresponding properties for which the sceptic can still press her question.</p>
<p>The auxiliary problem concerns how to extend particular solutions, such as those of Maddy and McGinn, Millikan, or Fodor, to the entirety of natural language. One simple-minded approach would be to take the conjunction of all existing solutions, so that each fixes the meaning of its own specialised terms. Sadly, in addition to being inelegant, this approach is unlikely to succeed. The existing solutions presuppose different, and incompatible, views of the underlying metaphysics. It would be inconsistent to take their conjunction. Furthermore, there is no guarantee that a conjunction of existing approaches would be able to cover the required ground: it is not obvious that even a conjunction would exhaust natural language. In this paper, I argue for an alternative approach. Kripke himself, in the context of a different discussion, indicates the way to proceed.</p>
<h1 id="the-algorithm-reply"><span class="header-section-number">2</span> The algorithm reply</h1>
<p>One possible reply to the sceptic that Kripke considers is the ‘algorithm reply’. The algorithm reply asserts that you meant <em>plus</em> rather than <em>quus</em> in your past use of ‘plus’ if you followed an addition algorithm when you applied ‘plus’ rather than a quaddition algorithm. Kripke gives an example of an addition algorithm:</p>
<blockquote>
<p>Take a huge bunch of marbles. First count out <span class="math inline">\(x\)</span> marbles in one heap. Then count out <span class="math inline">\(y\)</span> marbles in another. Put the two heaps together and count out the number of marbles in the union thus formed. The result is <span class="math inline">\(x + y\)</span>.</p>
</blockquote>
<p>The algorithm reply claims that if you followed these instructions, rather than those of a quus-like algorithm, then you succeeded in meaning <em>plus</em> rather than <em>quus</em> by ‘plus’. However, as Kripke points out, this won’t do as an answer to the sceptic, since the sceptic can repeat her challenge on the terms used by the algorithm. She can ask: what fact determined in your past use of the term ‘count’ that you meant <em>count</em> rather than <em>quount</em> – ‘where to ’quount’ a heap is to count it in the ordinary sense, unless the heap was formed as the union of two heaps, one of which has 57 or more items, in which case one must automatically give the answer ‘5’’ <span class="citation" data-cites="Kripke82">(Kripke 1982, 16)</span>. If one replies that one meant <em>count</em> rather than <em>quount</em> because one followed a <em>counting</em> algorithm rather than a <em>quounting</em> algorithm, then the sceptic can repeat her challenge on the terms of that algorithm, and so on. Kripke is undoubtably right that the algorithm reply, by itself, fails miserably as an answer to the sceptic. However, I wish to suggest that the algorithm reply, with a little help from the Church–Turing thesis, can play a different role: it can solve the auxiliary problem.</p>
<p>The auxiliary problem is the problem of extending answers to the sceptic for particular terms to the whole of natural language. Call the terms for which we already have an answer to the sceptic (those terms for which we already have a particular solution), the ‘basic terms’. Call the other terms, those for which we do not yet have an answer to the sceptic, the ‘non-basic terms’. In order for the algorithm reply to work, the meaning of the non-basic terms has to be fixable using only basic terms. At first sight, this looks unlikely. Natural language is incredibly heterogeneous. The claim that it can be reduced to combinations of a few basic terms looks implausible.</p>
<p>Before considering why the success of the algorithm reply seems unlikely, let us first consider the reply in more detail. The algorithm reply generalises a particular solution to sceptic to the entirety of natural language. In order to do this, it requires: (1) that we follow algorithms that give the conditions of correct application of all non-basic terms; (2) that those algorithms use only basic terms. If these two conditions are met, then the algorithm reply works as follows: in your past use of a non-basic term <span class="math inline">\(\ulcorner x\urcorner\)</span> you meant <span class="math inline">\(x\)</span> by it just in case you followed an appropriate algorithm when you applied the term. If you followed an appropriate <span class="math inline">\(\ulcorner x\urcorner\)</span>-algorithm when you applied <span class="math inline">\(\ulcorner x\urcorner\)</span>, then you meant <span class="math inline">\(x\)</span> by <span class="math inline">\(\ulcorner x\urcorner\)</span>; if you did not follow an appropriate <span class="math inline">\(\ulcorner x\urcorner\)</span>-algorithm, then you did not mean <span class="math inline">\(x\)</span> by <span class="math inline">\(\ulcorner x\urcorner\)</span>.</p>
<p>It is important to see that if (1) and (2) are met, then the algorithm reply provides a watertight answer to the auxiliary problem. In the ‘plus’ example above, the sceptic was able to raise her question by questioning the meanings of the component terms of the ‘plus’ algorithm. That strategy is now blocked. By hypothesis, all of the terms used by the algorithms of the algorithm reply are basic. Therefore, the sceptic’s problem cannot be raised again for those terms. Perhaps a different strategy is open to the sceptic. Perhaps she can question the determinacy of the notion of ‘following an algorithm’. However, this strategy is blocked too. What is involved in following a particular algorithm is fully spelled out by the terms of that algorithm. If those terms have determinate meaning, then it is determinate what is involved in following that algorithm. The sceptic cannot, for example, question whether one is really followed an algorithm <span class="math inline">\(A\)</span> or a divergent algorithm <span class="math inline">\(quA\)</span> when applying a term <span class="math inline">\(\ulcorner x\urcorner\)</span>. The only way that one could have followed a divergent algorithm <span class="math inline">\(quA\)</span> would be if algorithm <span class="math inline">\(A\)</span> had different terms, or terms with different meanings. But by hypothesis, algorithm <span class="math inline">\(A\)</span> has fixed terms with fixed meanings. So if one follows an algorithm with the terms of algorithm <span class="math inline">\(A\)</span>, there can be no question of one following a different algorithm <span class="math inline">\(quA\)</span>. Algorithms, if available at all, provide a watertight answer to the auxiliary problem.</p>
<p>There are three reasons why one might doubt that the algorithm reply can work.</p>
<p>First, one might doubt that one has the right set of basic terms. The algorithm reply requires that the conditions of correct application of every non-basic term can be defined using only basic terms. How can one be sure that one’s collection of basic terms is up to the job? Short of the Herculean task of actually providing all the algorithms, there seems no reason for thinking that one’s collection is adequate. Which terms one counts as basic will depend on the solution one favours to Kripke’s sceptical problem. If one follows Maddy and McGinn, then the basic terms will be proper names and natural kind terms. If one follows Millikan, then the basic terms will be evolutionarily salient terms. If one follows Fodor, then the basic terms will be those whose tokenings stand in asymmetric nomic relations with their corresponding properties. What reason do we have for thinking that any of these terms can specify the conditions of correct application of all other terms in natural language?</p>
<p>The second worry is that natural language may not be reducible to basic terms at all. Natural language could turn out to be holistic rather than reducible. Natural language is holistic just in case there is <em>no single small</em> subset of basic terms from which all other terms can have their conditions of correct application defined. If natural language is holistic, then although the conditions of correct application of some words can be given in terms of others, no systematic reduction to a single basic set of terms is possible. In other words, there is no privileged set of terms whose determinacy, if fixed, would fix the determinacy of the rest of language too. Natural language would not ‘bottom out’ in a single small basic vocabulary, instead it would hang together in a holistic web of definitions. If natural language is holistic, then the algorithm reply is doomed: <em>whatever</em> basic set of terms one chooses – short of the limit of choosing every term in natural language – the algorithm reply cannot extend that solution to other terms. In order for the algorithm reply to work, natural language must be reducible. Natural language is reducible just in case <em>there is</em> a small subset of basic terms from which all other terms can have their conditions of correct application defined. The worry is that we seem to have no reason to think that natural language is reducible, or reducible to any significant degree. Indeed, intuitions seem to favour a contrary nature: a glance at a dictionary seems to show a holistic structure, rather than reduction to a single basic vocabulary.</p>
<p>The third worry is that providing an algorithm for how to apply a term is tantamount to giving a definition of that term, and the existence of definitions is, in general, suspect. Doubts about the existence of definitions come from a number of sources, including Wittgenstein’s discussion of the difficulty of defining ‘game’, Quine’s argument against the existence of analytic truths, and cognitive science work, such as that of <span class="citation" data-cites="Rosch73">Rosch (1973)</span>, on the non-definitional nature of our concepts. The idea that terms generally have definitions looks, on many grounds, to be suspect. Therefore, the sceptic’s choice of a term that <em>does</em> have a definition, ‘plus’, may give the misleading impression that the algorithm reply can do more work than it can.</p>
<p>All of these concerns about the algorithm reply can be answered. With a small elaboration, the algorithm reply can be shown to be an adequate solution to the auxiliary problem.</p>
<h1 id="the-computability-assumption"><span class="header-section-number">3</span> The computability assumption</h1>
<p>Before discussing the solution, the idea needs to be introduced that following a rule can be understood as computing a function. This is not intended to be controversial.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> Functions are mappings from one set to another. Rules are instructions on how to act: they tell one, in this situation perform this action. It is possible to think of a rule as a function mapping a set of situations to a set of actions, and the process of following a rule as the process of computing that function.</p>
<p>There are at least two senses of rule, and two senses of function. Following the terminology of <span class="citation" data-cites="Church41">Church (1941)</span>, the term ‘function’ can refer to a function-in-extension or a function-in-intension. A <em>function-in-extension</em> is the set of input/output pairs associated with the function. For example, the function <span class="math inline">\(f(x) = x^2\)</span> where <span class="math inline">\(x\)</span> is a positive integer, considered as a function-in-extension, is the set of input/output pairs <span class="math inline">\(\{(1,1), (2,4), (3,9), \ldots \}\)</span>. A <em>function-in-intension</em> is a method for computing the set of input/output pairs. For example, the function <span class="math inline">\(f(x) = x^2\)</span> where <span class="math inline">\(x\)</span> is a positive integer, considered as a function-in-intension could be the method ‘Multiply <span class="math inline">\(x\)</span> by itself – take the result as <span class="math inline">\(f(x)\)</span>.’<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> Functions-in-extension are easily individuated: two functions-in-extension are the same just in case the two sets of I/O pairs are the same. The individuation conditions of functions-in-intension, outside a formalism like Church’s <span class="math inline">\(\lambda\)</span>-calculus, are less clear. However, it is generally true that functions-in-intension individuate more finely than functions-in-extension.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>The term ‘rule’ is similarly ambiguous. A rule could be a prescribed set of situation–action pairs; a rule could prescribe: in <em>this</em> situation perform <em>this</em> action. For example, the rule ‘Always wash your hands before you eat’, could be understood as the prescribed set of situation–action pairs: <span class="math inline">\(\{\)</span> (occasion<span class="math inline">\(_1\)</span> of eating, wash hands before), (occasion<span class="math inline">\(_2\)</span> of eating, wash hands before), <span class="math inline">\(\ldots \}\)</span>. Alternatively, the rule ‘Always wash your hands before you eat’ could be understood as <em>a way of achieving</em> those situation–action pairs: for example, ‘Before eating, walk to the bathroom, turn on the tap, wet your hands, pick up the soap, etc.’. The equivalence claim above between functions and rules is intended as a dual equivalence claim: an equivalence between functions-in-extension and rules understood extensionally, and an equivalence between functions-in-intension and rules understood intensionally. I will distinguish the two senses by referring to functions-in-extension and rules understood extensionally as ‘functions’, and functions-in-intension and rules understood intensionally as ‘algorithms’ or ‘rules’.</p>
<p>In order for Kripke’s sceptic to raise her challenge, the application conditions of natural language terms must be governed by rules. It is this assumption that enables the sceptic to transfer her concerns from rules in general to the application of natural language terms. In what follows, I take it for granted that the assumption that application of natural language terms is rule-governed is agreed on by all sides. The algorithm reply to the auxiliary problem adds an extra requirement to this assumption: that those rules be, in the sense defined below, <em>computable</em>.</p>
<p>This requirement can be phrased in many ways: as the requirement that the rules governing the application of natural language terms be effective procedures, as the requirement that the decision as to whether a natural language term correctly applies is determinable by finite means, as the requirement that a computer could, in principle, decide in finite time whether a given natural language term correctly applies in a certain case, or as the requirement that a computer could, in principle, reproduce human linguistic ability. Four things should be made clear about the computability assumption.</p>
<p>First, the computability assumption does not beg the question against the sceptic. Even if the computability assumption is correct, the sceptic is free to run her argument. The computability assumption entails that a rule for the correct application of a natural language term can given in terms that a computer can execute, but it does not entail that those terms themselves have determinate meaning. For example, the computability assumption entails that a rule for the correct application of a natural language term can be given in terms of the basic operations of a Turing machine, such as ‘scan symbol’, ‘write symbol’, ‘erase symbol’, and so on. But the computability assumption does not entail that these operations themselves have determinate meaning, i.e. that ‘scan symbol’ means <em>scan symbol</em> and not <em>squan symbol</em> (where to squan a symbol is the same as to scan a symbol unless that symbol is ‘57’ in which case the answer is ‘5’). If one wishes to argue that ‘scan symbol’ means <em>scan symbol</em>, one needs a separate argument to that effect.</p>
<p>Second, many respondents to Kripke’s sceptic are either sympathetic or already committed to the computability assumption. For instance, nearly all advocates of the computational theory of mind (CTM) are committed to it. The computability assumption cuts across the main disagreements within the CTM, such as whether the mind has a classical or a connectionist architecture. No matter what kind of computer the mind is, if that computer is responsible for our linguistic abilities, then the rules that govern those abilities must, in the sense above, be computable.</p>
<p>Third, the computability assumption entails that a rule that a computer is capable of following can be given for the application of each natural language term, but it does not entail that there must only be one such rule for each term. The same function can be computed in many different ways. A natural language term may therefore have more than one algorithm associated with its conditions of correct application.</p>
<p>Finally, over and above the commitments of philosophers to the computability assumption, there seem to be good reasons for taking that assumption on board, at least pending good reasons otherwise. First, computable methods have massive expressive power. There is so much that can be done with computable functions that it seems strange to lose hope before one starts. Many cases of apparent incomputable behaviour can be dealt with without violating the core of the computability assumption.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> Second, one has to opt out of mainstream intuitions if one denies the computability assumption. Denying the computability assumption entails that a computer, even in the form of a humanoid robot, could never master natural language. This seems like a controversial <em>a priori</em> commitment to make.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<p>None of these reasons is conclusive. I do not know of any argument strong enough to show that the rules governing natural language must be computable. All that I wish to claim is that the computability assumption is <em>prima facie</em> plausible: it should be accepted pending good reasons otherwise. Given the magnitude of assumptions that get made in solutions to Kripke’s sceptic, the computability assumption is a fairly mild addition that yields a healthy pay-off.</p>
<h1 id="the-pay-off"><span class="header-section-number">4</span> The pay-off</h1>
<p>Let us return to the reasons why the algorithm reply was suspected to be unsatisfactory, and consider those reasons in reverse order.</p>
<p>First, there was a worry that providing an algorithm for how to apply a term is tantamount to providing a definition of that term. This is false. Algorithms are not intended to be definitions, they are intended to provide extensional equivalence. Extensional equivalence is a much weaker condition than synonymy. There is no reason to think that doubts about the existence of definitions should carry over to doubts about the existence of algorithms for applying terms. Indeed, the computability assumption entails that they do not. If the computability assumption is true, then there must be computable rules governing the correct application of natural language terms. Hence, there must exist algorithms for applying those terms. These algorithms fix the correct application conditions of those terms, and this is exactly what Kripke’s sceptic questions.</p>
<p>The second worry was that natural language may be holistic rather than reducible. If natural language is holistic, then the algorithm reply cannot solve the auxiliary problem: no matter which set of terms one takes as basic, there is no small subset from which the application conditions of all other terms can be defined. However, if the computability assumption is true and the Church–Turing thesis is accepted, then natural language can be shown to be reducible.</p>
<p>The computability assumption entails that, <em>for each term</em>, there are finite means in terms of which its correct application can be specified. However, the computability assumption does not entail that <em>the same</em> finite means – the same set of basic terms – work in each case. For example, it may be that a term <span class="math inline">\(\ulcorner a\urcorner\)</span> has an algorithm governing its correct application that uses the set of basic terms <span class="math inline">\(\{ \ulcorner x\urcorner, \ulcorner y\urcorner, \ulcorner z\urcorner\}\)</span>, and that another term <span class="math inline">\(\ulcorner b\urcorner\)</span> has an algorithm governing its correct application that uses a different set of basic terms <span class="math inline">\(\{ \ulcorner u\urcorner, \ulcorner v\urcorner, \ulcorner w\urcorner\}\)</span>. It may be that each non-basic term in natural language requires a different set of basic terms. Even if computable algorithms determine the conditions of correct application of terms, that does not mean that the total number of terms used by those algorithms is any fewer than the total number of terms in natural language. It is compatible with the computability assumption that language be holistic. Fortunately, there is another result that shows that language is reducible under these conditions: the Church–Turing thesis.</p>
<p>The Church–Turing thesis holds that if a function – an input/output pattern – is computable at all, then it is computable using algorithms that use <em>only a small number of basic terms</em>. Computers can produce an incredible variety of I/O behaviour, including, if the computability assumption is true, the linguistic I/O behaviour of humans. One might think that such a variety of I/O behaviour has to be reflected in a corresponding variety of basic predicates. The Church–Turing thesis says that this is not the case. If a rule can be specified using <em>some finite means or other</em> (which the computability assumption asserts), then it can be specified using one of any number of small sets of basic predicates. A small set of basic terms is enough to specify algorithms for producing any computable behaviour. Therefore, if the Church–Turing thesis is true, language is reducible a small set of basic terms.</p>
<p>The final worry was whether one’s set of basic terms is up to the job of defining the conditions of correct application for all other terms. Depending on which response to the sceptic one favours – Maddy’s and McGinn’s, Millikan’s, or Fodor’s – one will end up with a different set of basic terms. How can one be sure that one’s set of basic terms is adequate to define the conditions of correct application of all other terms? If the computability assumption and the Church–Turing thesis are correct, then this question can be given at least a provisional answer: a set of basic terms is adequate just in case that set defines the architecture of a universal computing machine.</p>
<p>A universal computing machine is a machine that can, in principle, compute any computable function. If natural language is computable at all (which it is by the computability assumption), then it is computable by any universal computing machine. The best known universal computing machine is the universal Turing machine, but there are plenty of other examples: universal register machines, universal Post machines, universal automata in Conway’s game of life, and electronic PCs with unbounded memory. These machines differ in the algorithms that they run, but they share the characteristic of being capable of reproducing the input/output pattern of any other computer. The algorithms that a universal machine runs consist in finite combinations of a finite number of basic instructions. For a Turing machine, the basic instructions are ‘scan symbol’, ‘erase symbol’, ‘move head left’, and so on; for a register machine the basic instructions are ‘increment register’, ‘decrement register’, ‘branch if zero’, and so on. The basic instructions of a machine are the basic terms of that machine’s algorithms. If those basic instructions have a fixed meaning – a meaning immune to sceptical reinterpretation – then the algorithm followed by the machine is immune to sceptical reinterpretation too.</p>
<p>The worry that we faced was whether a particular set of basic terms is up to the job of defining the conditions of correct application for all other terms. The current claim is that <em>if</em> one’s set of basic terms is up to the job of defining the basic instructions of a universal machine, <em>then</em> it is up to the job of defining the application conditions of all other terms. The justification for this claim is as follows. If natural language is computable, then it is computable by any universal computer. The algorithms that such a universal computer follows consist of basic instructions. If those basic instructions are immune to sceptical reinterpretation, then the algorithms are immune to sceptical reinterpretation too. The basic instructions of the universal computer are immune to sceptical reinterpretation if those basic instructions <em>coincide with our set of basic terms</em> – the set of terms for which the sceptic’s question has already been answered. Therefore, if one’s set of basic terms define the basic operations of a universal machine, then that set of basic terms is up to the job of defining the application conditions of every term in natural language.</p>
<p>This is only half of an answer to our worry. How do we know that the antecedent of this conditional is true? How do we know that our set of basic terms <em>does</em> define the architecture of a universal computing machine? There are no guarantees, but some encouraging results here. It is well known that the requirements for creating a universal computing machine are minimal. With only a handful of predicates one can specify a universal computing architecture (there is a small industry creating universal computers out of simple and unexpected resources). Existing universal machines include not only those listed above, but also recurrent neural networks (finite-precision inputs/outputs/weights, infinite-precision signals initialized to zero), finite state machines with two stacks, and nearly all programming languages (including URISC, which has only one instruction). Only a modest selection of predicates is needed to create a universal computing machine. It is likely that if an existing response to the sceptic – e.g. Maddy’s and McGinn’s, Millikan’s, or Fodor’s – works, then the set of terms for which it works will be adequate to define the architecture of a universal computing machine. If this condition is met, then that set will be able to specify the application conditions of all other terms in natural language.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<h1 id="commitment-to-the-ctm"><span class="header-section-number">5</span> Commitment to the CTM</h1>
<p>There is a close connection between the basic terms of the algorithm reply and the basic instructions of a universal computing machine. The basic terms of the algorithm reply specify the instructions of a universal computing machine that is able to decide, by following appropriate algorithms, whether a given natural language term correctly applies in a given case. Correspondingly, if whether a natural language term correctly applies in a given case is decidable by a computer, and the basic instructions of that computer are not susceptible to sceptical reinterpretation, then the correct application conditions of natural language are not susceptible to sceptical reinterpretation either. A consequence is that, if one sees the decision as to whether a given term correctly applies as lying within the human mind, a factor influencing the choice of basic terms will be if, and in what sense, one sees the human mind as a computer. If one sees the human mind as computer of a particular sort (classical, connectionist, etc.), then it will be natural to try to specify the rules for applying natural language terms in terms of the basic operations of that machine. This suggests one apparent problem with the computability assumption: it presupposes that the human mind is a computer, and this is far from uncontroversial.</p>
<p>This problem is not as serious as it may seem. The issue need only arise to the extent that one takes Kripke’s sceptic as presenting a challenge about individual meaning or mental content. This is one way to read the sceptic’s challenge, but not the only way. One could take the sceptic as presenting a challenge about the meaning of terms in public language. On this understanding, an advocate of the computability assumption need not assume that individuals perform computations. The computations that fix non-basic terms could be computations performed by groups. The idea that computations can be performed by groups rather than individuals is not unusual. <span class="citation" data-cites="Hutchins95">Hutchins (1995)</span> and <span class="citation" data-cites="Clark97">Clark (1997)</span> give examples in which groups of humans cooperate and, in conjunction with artefacts, perform a computation that does not take place inside the head of any single individual.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> If the computations that fix the meaning of non-basic terms are of this public kind, then they need not involve any commitment to individuals performing computations or privately following rules.</p>
<p>By the same reasoning, the computability assumption is compatible with <span class="citation" data-cites="Putnam75b">Putnam (1975)</span>‘s claim about the division of linguistic labour. The algorithms for correctly applying ’elm’ could be computational without lying inside the head of every competent language user; the algorithms could be distributed among experts.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<p>It is worth noting that if one does accept a version of the CTM, then the algorithm reply suggests a possibility that is usually ignored in discussions of Kripke’s paradox. This possibility is that the basic terms may themselves not be terms of natural language: they may be basic operations of the human mind. If the human mind is computer, then like any computer, it will have certain basic operations. If the correct application of natural language terms is decided within the human mind, then the rules for applying those terms must ultimately be fixed in terms of the basic operations of that computer. Therefore, if one fixes determinacy for those basic operations, then one will thereby fix determinacy for all terms in natural language. Since the basic operations of the human mind are likely to be simple and evolutionarily salient, the task of fixing their determinacy might be easier than that of fixing the determinacy of many natural language terms.</p>
<h1 id="conclusion"><span class="header-section-number">6</span> Conclusion</h1>
<p>Respondents to Kripke’s sceptic ought to worry about whether their solutions generalise to the whole of natural language. The algorithm reply provides a way of answering this worry. One might have three concerns about whether the algorithm reply is possible. If the computability assumption and the Church–Turing thesis are correct, then these concerns can be answered. Two further questions remain. The first is whether we, as language users, <em>in fact</em> follow the rules given by a particular algorithm reply. For example, in the case of ‘plus’ it is unlikely that we decide correct application by counting marbles. A full solution would depend on identifying our actual linguistic rules, and this is an empirical matter. The second question is whether a set of basic terms is adequate to define a universal computing machine. The requirements for creating a universal computing machine are minimal, so it is likely that this condition can be met. However, a definitive answer to this question has to wait until particular solutions specify the set of terms for which they work. This is something that remains to be done for many particular solutions. Until these two questions are answered, the algorithm reply remains a promissory note. However, as things stand it is our best chance of solving the auxiliary problem.</p>
<h1 id="acknowledgements" class="unnumbered">Acknowledgements</h1>
<p>I would like to thank Peter Lipton and Martin Kusch for comments on an earlier version of this paper.</p>
<h1 id="bibliography" class="unnumbered">Bibliography</h1>
<div id="refs" class="references">
<div id="ref-Church41">
<p>Church, A. 1941. <em>The Calculi of Lambda-Conversion</em>. Princeton, NJ: Princeton University Press.</p>
</div>
<div id="ref-Clark97">
<p>Clark, A. 1997. <em>Being There</em>. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Dreyfus92">
<p>Dreyfus, H. L. 1992. <em>What Computers Still Can’t Do</em>. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Fodor90f">
<p>Fodor, J. A. 1990. <em>A Theory of Content and Other Essays</em>. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Ginet92">
<p>Ginet, C. 1992. “The Dispositionalist Solution to Wittgenstein’s Problem About Understanding a Rule: Answering Kripke’s Objections.” In <em>Midwest Studies in Philosophy</em>, edited by P. A. French, T. E. Jr. Uehling, and H. K. Wettstein, 17:53–73. Notre Dame: University of Notre Dame Press.</p>
</div>
<div id="ref-Haugeland81">
<p>Haugeland, J. 1981. “Semantic Engines: An Introduction to Mind Design.” In <em>Mind Design</em>, edited by J. Haugeland, 1–34. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Hutchins95">
<p>Hutchins, E. 1995. <em>Cognition in the Wild</em>. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Kripke82">
<p>Kripke, S. A. 1982. <em>Wittgenstein on Rules and Private Language</em>. Cambridge, MA: MIT Press.</p>
</div>
<div id="ref-Maddy84">
<p>Maddy, P. 1984. “How the Causal Theorist Follows a Rule.” <em>Midwest Studies in Philosophy</em> 9: 457–77.</p>
</div>
<div id="ref-McGinn84">
<p>McGinn, C. 1984. <em>Wittgenstein on Meaning</em>. Oxford: Blackwell.</p>
</div>
<div id="ref-Mellor77">
<p>Mellor, D. H. 1977. “Natural Kinds.” <em>The British Journal for the Philosophy of Science</em> 28: 299–312.</p>
</div>
<div id="ref-Miller.Wright02">
<p>Miller, A., and C. Wright, eds. 2002. <em>Rule-Following and Meaning</em>. Chesham: Acumen.</p>
</div>
<div id="ref-Millikan90">
<p>Millikan, R. G. 1990. “Truth Rules, Hoverflies, and the Kripke–Wittgenstein Paradox.” <em>Philosophical Review</em> 99: 323–53.</p>
</div>
<div id="ref-Putnam75b">
<p>Putnam, H. 1975. “The Meaning of ‘Meaning’.” In <em>Mind, Language and Reality, Philosophical Papers, Vol. 2</em>, 215–71. Cambridge: Cambridge University Press.</p>
</div>
<div id="ref-Rosch73">
<p>Rosch, E. 1973. “On the Internal Structure of Perceptual and Semantic Categories.” In <em>Cognitive Development and the Acquisition of Language</em>, edited by T. Moore. New York, NY: Academic Press.</p>
</div>
<div id="ref-Searle80">
<p>Searle, J. R. 1980. “Minds, Brains, and Programs.” <em>Behavioral and Brain Sciences</em> 3: 417–24.</p>
</div>
<div id="ref-Zymach76">
<p>Zymach, E. 1976. “Putnam’s Theory of the Reference of Subject Terms.” <em>The Journal of Philosophy</em> 73: 116–27.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For example, see <span class="citation" data-cites="Miller.Wright02">Miller and Wright (2002)</span> and references.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><span class="citation" data-cites="Ginet92">Ginet (1992)</span> defends a similar equivalence of functions and rules.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>In Church’s <span class="math inline">\(\lambda\)</span>-notation: <span class="math inline">\(f(x) = \lambda x . x x\)</span>.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><span class="citation" data-cites="Church41">Church (1941)</span>, pp. 2–3.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>For example, consider terms such as ‘… is a non-halting Turing machine’, whose correct application is in principle not decidable by a computer. There are at least three ways of dealing with such cases. One is to treat them as non-computable composites made up of components, such as negation, ‘halting’, and ‘Turing machine’, that are governed by computable rules. Another is to treat them as promissory notes on which we cannot actually deliver over the full infinite domain, but to which we can provide a finite approximation. Finally, one could treat such expressions as having a different semantic content from the descriptive role that they appear to have, e.g. give them an expressivist treatment.<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Some philosophers claim to demonstrate <em>a priori</em> that a computer cannot understand natural language (e.g. <span class="citation" data-cites="Searle80">Searle (1980)</span>, <span class="citation" data-cites="Dreyfus92">Dreyfus (1992)</span>, <span class="citation" data-cites="Haugeland81">Haugeland (1981)</span>). However, the computability assumption is strictly speaking weaker than the claims that these philosophers attack. First, as discussed in Section 5, the computability assumption does not entail that computations take place inside individual human heads. Second, the computability assumption is true provided a simulation of a human (Searle), a connectionist architecture (Dreyfus), or a suitably human-like robot (Haugeland) can correctly apply natural language terms. Third, the computability assumption only concerns correctness conditions, it does not concern all aspects of language understanding, or indeed any other mental process. The computability assumption may be false, but it is not obviously incompatible with the principal arguments against the computational view of the mind.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Note that the claim is not that the number of basic terms of a universal computer <em>must</em> be small, only that it <em>can</em> be small (one could design a universal computer with a labyrinthine architecture that has a huge number of basic operations). How is the number of basic terms counted? The number of basic terms is the minimum number whose meaning needs to be fixed in order to specify the architecture of the computing machine in question. (Suppose you are asked to write out a full specification of the architecture, what is the minimum number of terms you need to use to do so?)<a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><span class="citation" data-cites="Hutchins95">Hutchins (1995)</span> gives the example of computing the position of a US Navy battle group.<a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><span class="citation" data-cites="Putnam75b">Putnam (1975)</span>’s point about indexical nature of natural kind terms requires a different treatment. One strategy would be to follow Maddy and McGinn and treat natural kind terms as basic, and hence not requiring algorithms to specify their conditions of application. Another would be to reject Putnam’s treatment of natural kinds terms in favour of a descriptivist view; see <span class="citation" data-cites="Mellor77">Mellor (1977)</span>, <span class="citation" data-cites="Zymach76">Zymach (1976)</span> for defence of such a view.<a href="#fnref9" class="footnote-back">↩</a></p></li>
</ol>
</section>
</div>

                        </div>
                        
                    </div>

                </div>

                <div class="col col-4">     
                    <div class="hide-print hide-sm">
                        
                        <h1 style="margin-top: 0px;">Contents</h1>
                        <ul class="unstyled">
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#introduction"><span style="font-size: 14px;">1 &nbsp; Introduction</span></a>
                                
                            </li>
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-algorithm-reply"><span style="font-size: 14px;">2 &nbsp; The algorithm reply</span></a>
                                
                            </li>
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-computability-assumption"><span style="font-size: 14px;">3 &nbsp; The computability assumption</span></a>
                                
                            </li>
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#the-pay-off"><span style="font-size: 14px;">4 &nbsp; The pay-off</span></a>
                                
                            </li>
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#commitment-to-the-ctm"><span style="font-size: 14px;">5 &nbsp; Commitment to the CTM</span></a>
                                
                            </li>
                            
                            <li>
                                
                                <a href="http://marksprevak.com/publications/kripke-s-paradox-and-the-church-turing-thesis-2008/#conclusion"><span style="font-size: 14px;">6 &nbsp; Conclusion</span></a>
                                
                            </li>
                            
                        </ul>
                        
                        
                        <div style="border-bottom: 0; padding-bottom: 10px; width:80%; margin-left: auto; margin-right: auto;">
                            <img src="http://marksprevak.com/img/pubs/synthese.jpg" alt="">
                        </div>
                        
                    </div>
                </div>

            </div>

        </div>

        
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-600543-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 
        'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();

(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)

</script>

    </body>
</html>
