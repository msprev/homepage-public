<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Predictive coding III: The algorithmic level | Mark Sprevak</title>
        <meta name="description" content="">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://marksprevak.com/kube/css/kube.min.css" />
<link rel="stylesheet" href="https://marksprevak.com/css-customisations/sprevak.css" />
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<title>Mark Sprevak</title>
<base href="https://marksprevak.com/">
<link rel="canonical" href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/">

<link href="https://fonts.googleapis.com/css?family=Roboto:400,700%7CLato:400,700" rel="stylesheet">

    </head>
    <body>
        <div class="page wrapper">

            <header class="header">
                <div class="is-navbar-container" style="padding-bottom: 6px; padding-top: 0px; border-bottom: 1px solid; border-color: rgba(0, 0, 0, 0.3);">
    <div class="is-brand">
        <div class="titlebar"><a href="https://marksprevak.com/">Mark&nbsp;Sprevak</a></div>
        
        <a href="#"
                style="color: rgba(0, 0, 0, 0.8); text-decoration: none; border-bottom: none; font-size:18px;"
                class="is-hidden-print nav-toggle is-push-right-mobile is-shown-mobile icon-kube-menu"
                data-kube="toggle"
                data-target="#top-navbar"></a>
    </div>
    <div id="top-navbar" class="is-navbar is-hidden-print is-hidden-mobile">
        <nav class="is-push-right">
            <ul style="text-align: right;">
                
                
                
                
                
                <li  >
                    <a href="https://marksprevak.com/publications/" style="text-decoration: none; border-bottom: none;">Publications</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/talks/" style="text-decoration: none; border-bottom: none;">Talks</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/outreach/" style="text-decoration: none; border-bottom: none;">Outreach</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/cv/" style="text-decoration: none; border-bottom: none;">CV</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/phds/" style="text-decoration: none; border-bottom: none;">PhD study</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/mscs/" style="text-decoration: none; border-bottom: none;">MSc study</a>
                </li>
                
                
                
                <li  >
                    <a href="https://marksprevak.com/teaching/" style="text-decoration: none; border-bottom: none;">Teaching</a>
                </li>
                
                
            </ul>
        </nav>
    </div>
</div>

            </header>

            <main class="main">
                <div class="is-row">

                    <div class="is-col is-67">     

                        <div style="padding-bottom: 30px;">
                            <div style="margin-bottom: 10px;">
                                <h1 class="is-color-black" style="margin-top: 0px; margin-bottom: 0px;">Predictive coding III: The algorithmic level</h1>
                                
                                <p class="is-muted" style="margin-top: 10px;">
                                    
                                        draft  &nbsp;
                                    
                                    
                                </p>
                                <p class="is-small" style="margin-top: 10px;">
                                    <span>Last updated 19 October 2021</span>
                                    
                                </p>
                            </div>
                            <div class="is-hidden-print">
                                
<a href="https://marksprevak.com/pdf/paper/Sprevak--Predictive-Coding-3-Algorithm.pdf" target="_blank" class="label is-primary is-focus" style="margin-left: 0px; margin-right:5px;">
    <i class="far fa-file-pdf" style="font-size: 12px;"></i>
    &nbsp;PDF
</a>



<a href="http://philsci-archive.pitt.edu/id/eprint/19488" target="_blank" class="label is-tertiary is-focus" style="margin-left: 0; padding-left: 0; margin-right:2px;">
    preprint
</a>



                            </div>
                        </div>

                        <div class="is-hidden-mobile">
                            
                        </div>
                        <div class="is-shown-mobile">
                            
                        </div>

                        <div>
                            
                            <div class="is-shown-mobile">
                                
                                    <h1 style="margin-top: 0px;" id="internal-mds-toc">Contents</h1>
                                    <ul class="is-unstyled">
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#introduction"><span style="visibility: visible;">1</span> &nbsp;  Introduction</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#predictive-coding-in-one-layer"><span style="visibility: visible;">2</span> &nbsp;  Predictive coding in one layer</a>
            
        </span>
        
    </li>
    
    <li>
        
        <ul class="is-unstyled" style="margin-left: 15px;">
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-computational-task"><span style="visibility: visible;">2.1</span> &nbsp;  The computational task</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-inference-algorithm"><span style="visibility: visible;">2.2</span> &nbsp;  The inference algorithm</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-learning-algorithm"><span style="visibility: visible;">2.3</span> &nbsp;  The learning algorithm</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#precision-weighting"><span style="visibility: visible;">2.4</span> &nbsp;  Precision weighting</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#extending-the-algorithm"><span style="visibility: visible;">2.5</span> &nbsp;  Extending the algorithm</a>
                    
                </span>
            </li>
            
        </ul>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#an-algorithm-not-an-implementation"><span style="visibility: visible;">3</span> &nbsp;  An algorithm, not an implementation</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#hierarchical-structure"><span style="visibility: visible;">4</span> &nbsp;  Hierarchical structure</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#representing-probabilistic-guesses"><span style="visibility: visible;">5</span> &nbsp;  Representing probabilistic guesses</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#going-beyond-perception"><span style="visibility: visible;">6</span> &nbsp;  Going beyond perception</a>
            
        </span>
        
    </li>
    
    <li>
        
        <ul class="is-unstyled" style="margin-left: 15px;">
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#example-of-motor-control"><span style="visibility: visible;">6.1</span> &nbsp;  Example of motor control</a>
                    
                </span>
            </li>
            
        </ul>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#conclusion"><span style="visibility: visible;">7</span> &nbsp;  Conclusion</a>
            
        </span>
        
    </li>
    
</ul>

                                
                                
                            </div>
                            <div class="article-style">
                                <div>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>At Marr’s computational level, predictive coding suggests that the task facing the brain is to minimise its long-term, precision-weighted sensory prediction error. This article focuses on the algorithm and representations by which the brain attempts to accomplish this task – in other words, what predictive coding says at Marr’s algorithmic level. In principle, a huge range of possible algorithms could be used to minimise sensory prediction error. Furthermore, nothing has been assumed about the brain’s <em>success rate</em> in solving this computational problem. There is no commitment within the predictive coding programme to the algorithm for minimising sensory prediction error being entirely reliable or always guaranteed to solve the problem in every case. This leaves a very wide field of possible candidates.</p>
<p>Among the algorithms that could conceivably be used to minimise sensory prediction error include various versions of approximate Bayesian inference – sampling-based techniques such as Monte Carlo simulation as well as the variational Bayesian methods favoured by advocates of predictive coding. It also includes non-Bayesian methods that, while not optimal in the respects favoured by Bayesians, are nevertheless capable of producing effective results in many circumstances. This latter includes a vast and diverse range of algorithms spanning from simple regression methods and likelihood maximisation to sophisticated forms of reinforcement learning and supervised learning. Even a large enough look-up table could, in principle, be used to allow the brain to minimise sensory prediction error.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Predictive coders tend to have relatively specific proposals about how the brain minimises its sensory prediction errors. Details vary between these proposals – currently, there is no agreed algorithm for predictive coding – but certain broad motifs concerning that algorithm tend to be repeated. These include the idea that the algorithm should involve: (i) a <em>multi-layered, hierarchically structured artificial neural network</em>; (ii) a repeated <em>duplex arrangement of prediction and error units</em> within each layer; (iii) each layer functioning so as to <em>minimise prediction error about the state of the layer below</em>. Some of the formal states of this algorithm may also be interpreted, in a further semantic step, as <em>probabilistic representations</em> and the manner in which they are transformed as a version of <em>approximate Bayesian inference</em>.</p>
<p>These points will be unpacked in more detail below. In Section 2, I describe how a single layer of the artificial neural network works. In Section 3, I describe how multiple layers connect to form a larger, hierarchically structured artificial neural network. Section 4 describes how the formal states of the artificial neural network can be given a semantic interpretation that allows the network to be viewed as performing approximate Bayesian inference. Section 5 describes how the algorithm can be used to model cognitive processes outside perceptual inference and perceptual learning – for example, motor control. Section 6 provides a brief conclusion and review.</p>
<h1 data-number="2" id="predictive-coding-in-one-layer"><span class="header-section-number">2</span> Predictive coding in one layer</h1>
<p>Predictive coding’s algorithm involves an artificial neural network with multiple layers. This section focuses on a single layer. For the sake of simplicity, I describe the bottom-most layer – the one closest to sensory input. The workings of this layer are also deliberately simplified, for ease of exposition. More sophisticated versions are sketched in Section 2.5. In Section 3, I describe how multiple layers, each with a structure identical to that described in this section, are composed to form a hierarchy.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h2 data-number="2.1" id="the-computational-task"><span class="header-section-number">2.1</span> The computational task</h2>
<p>The computational task of a single layer in predictive coding is assumed to be the same as that of the entire system: namely, to minimise its sensory prediction error. Each layer takes its ‘sensory’ input from below. The bottom-most layer takes, as its input, the signals delivered by the brain’s external sensory organs. The computational goal of a layer is to converge on (i) a set of <em>prediction values</em> and (ii) a <em>generative model</em> that, when appropriately combined, reconstruct (i.e. predict) its sensory input as closely as possible. The <em>algorithm</em> by which the layer does this consists in two types of stepwise operation that occur on different time scales: (i) updating the activation values of the artificial neural network (‘inference’); (ii) updating the connection weights of the artificial neural network (‘learning’).</p>
<p>Before describing the steps involved in inference and learning in quantitative terms, it is necessary to first formalise the computational task of a layer.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> For the sake of simplicity, we will ignore the effects of both precision-weighting and long-term averaging of the error. Assume that the task of a layer is to <em>minimise its current sensory prediction error</em>. How might that problem be characterised in formal, mathematical terms? We might say that there are <span class="math inline">\(m\)</span> numerical values, <span class="math inline">\(x_1\)</span> to <span class="math inline">\(x_m\)</span>, which we label the ‘sensory inputs’. These numbers might correspond to the magnitude of physical activities in the brain’s sensory organs, e.g. the firing rates of individual sensory receptors. However, from the point of view of the algorithmic-level description, the particular details of the physical implementation are intentionally ignored or bracketed.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The <span class="math inline">\(x_i\)</span> are simply notional values to be estimated or predicted. A layer’s task is to estimate these <span class="math inline">\(x_i\)</span> values (‘sensory input’) as accurately as possible using another set of numerical values, <span class="math inline">\(y_1\)</span> to <span class="math inline">\(y_n\)</span>, (which we will call the ‘prediction values’) and a matrix of numerical weights, <span class="math inline">\(w_{0,0}\)</span> to <span class="math inline">\(w_{m,n}\)</span> (which we will call the ‘generative model’).</p>
<p>Let us call a layer’s estimate of its sensory input, <span class="math inline">\(x_i\)</span>, based on its prediction values and its generative model, its ‘prediction’, <span class="math inline">\(r_i\)</span>. In the simplest version of a predictive coding algorithm, the system will generate these predictions, <span class="math inline">\(r_i\)</span>, using a <em>linear</em> generative model: it estimates the <span class="math inline">\(x_i\)</span> using a weighted sum of <span class="math inline">\(y_j\)</span> values, where the weight of each prediction value is determined by the corresponding entry of the generative model, <span class="math inline">\(w_{i, j}\)</span>. The function of the generative model is to modulate how much the value of each <span class="math inline">\(y_j\)</span> contributes to the estimate of each <span class="math inline">\(x_i\)</span>. Formally, a linear model estimates the <span class="math inline">\(x_i\)</span> values in the following way:</p>
<p><span class="math display">\[
r_1 = w_{0,0} y_0 + w_{0,1} y_1 + \ldots + w_{0,n} y_n
\]</span> <span class="math display">\[
r_2 = w_{1,0} y_0 + w_{1,1} y_1 + \ldots + w_{1,n} y_n
\]</span> <span class="math display">\[
\vdots
\]</span> <span class="math display">\[
r_m = w_{m,0} y_0 + w_{m,1} y_1 + \ldots + w_{m,n} y_n
\]</span></p>
<p>Or, in vector notation, <span class="math inline">\(\mathbf{r} = \mathbf{Wy}\)</span>, where <span class="math inline">\(\mathbf{r}\)</span> is the layer’s prediction, <span class="math inline">\(\mathbf{W}\)</span> is the generative model, and <span class="math inline">\(\mathbf{y}\)</span> are the prediction values that, when combined with elements of <span class="math inline">\(\mathbf{W}\)</span>, generate the prediction.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> The computational task of a single layer is thus to find <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> values that produce an <span class="math inline">\(\mathbf{r}\)</span> that matches the actual input, <span class="math inline">\(\mathbf{x}\)</span>, as closely as possible.</p>
<p>The measure of by how much a layer misses its goal is the ‘sensory prediction error’, <span class="math inline">\(\mathbf{e} = \mathbf{x} - \mathbf{r}\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> Sensory prediction error, <span class="math inline">\(\mathbf{e}\)</span>, is an <span class="math inline">\(m\)</span>-dimensional vector. The task of the layer is to minimise this vector. In order to do this, one needs a measure of ‘how much’ prediction error there is in <span class="math inline">\(\mathbf{e}\)</span>. Typically, this figure is assumed to be the sum of the squares of the values in <span class="math inline">\(\mathbf{e}\)</span>. A layer’s computational task is, therefore, to find <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> that minimise the sum of the squares of the prediction errors over its sensory inputs, i.e. find <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> that, when combined to produce a prediction, <span class="math inline">\(\mathbf{r}\)</span>, minimise <span class="math inline">\(\sum_i (x_i - r_i)^2\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<h2 data-number="2.2" id="the-inference-algorithm"><span class="header-section-number">2.2</span> The inference algorithm</h2>
<p>So far, we have only described a layer’s computational task. We have not said <em>how</em> a layer should go about finding a combination of <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> that minimises its sensory prediction error. What would such an algorithm look like?</p>
<p>Generally speaking, an algorithm is a series of simple, rule-governed steps that can, in principle, be mechanised. An algorithm for solving the task is shown in Figure 1. The algorithm does not take the form of a flowchart or a sequence of explicit instructions (e.g. ‘if <span class="math inline">\(A\)</span>, then <span class="math inline">\(B\)</span>’). Instead, it takes the form of an <em>artificial neural network</em> (ANN). The ANN has ‘error’ units (<span class="math inline">\(e_1\)</span> to <span class="math inline">\(e_m\)</span>) and ‘prediction’ units (<span class="math inline">\(y_1\)</span> to <span class="math inline">\(y_n\)</span>). The prediction and error units are linked by a series of excitatory and inhibitory ‘connections’. The numerical ‘activation level’ associated with each unit in the ANN is the value of the variable of the same name, <span class="math inline">\(e_i\)</span> or <span class="math inline">\(y_j\)</span>. The ‘strength’ associated with each connection between the units is the weight of the corresponding element, <span class="math inline">\(w_{i, j}\)</span>, of the matrix <span class="math inline">\(\mathbf{W}\)</span>. The excitatory and inhibitory connections of the ANN are arranged so as to be of equal and opposite weight: the excitatory connection between <span class="math inline">\(e_i\)</span> and <span class="math inline">\(y_j\)</span> of weight <span class="math inline">\(w_{i, j}\)</span>, is paired by an inhibitory connection between them, running in the opposite direction, of weight <span class="math inline">\(-w_{i, j}\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<div id="fig1">
<figure>
<img src="img/ann1.png" title="opt title" style="width:50.0%" alt="A single layer in predictive coding diagram adapted from, p. 95, p. 44(Harpur 1997 p. 44; diagram adapted from Spratling 2017 p. 95)" /><figcaption aria-hidden="true">A single layer in predictive coding <span class="citation" data-cites="Spratling17 Harpur97">(Harpur 1997 p. 44; diagram adapted from Spratling 2017 p. 95)</span></figcaption>
</figure>
</div>
<p>Unlike real neurons, the outputs of the individual units of the ANN in a linear predictive coding model are assumed to be a linear function of their inputs. Their numerical activation level is the sum of their connected inputs weighted by the connection strength for that input, <span class="math inline">\(y_j = \sum_i w_{i, j} e_i\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> This rule, called the ‘activation function’, specifies how the activation level of a unit depends on the activation levels of its incoming connected units and the weights of those connections.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<p>When the algorithm runs, the sequence of addition and multiplication operations specified by the activation function are applied in turn to every unit of the network (<span class="math inline">\(y_i\)</span> and <span class="math inline">\(e_i\)</span>) to update its activation level, and then the entire process is repeated. Over time, the <span class="math inline">\(y_i\)</span> and <span class="math inline">\(e_i\)</span> values will progressively change. The <span class="math inline">\(y_i\)</span> values may eventually settle into a stable set of numbers or they may cycle between different sets of numbers. It is possible to prove that if an ANN with the aforementioned activation function and topology is run on some fixed input <span class="math inline">\(\mathbf{x}\)</span>, the activation level of the <span class="math inline">\(\mathbf{y}\)</span> units in the network will tend to converge on values that accomplish the task described in Section 2.1. In other words, the activation values of the <span class="math inline">\(\mathbf{y}\)</span> units will gradually vary – in a way that is wholly determined by the activation function and the structure of the network – towards a new set of values that tend to minimise the prediction error (i.e. that minimise the sum of the squares of the components of <span class="math inline">\(\mathbf{e}\)</span>).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> If the <span class="math inline">\(\mathbf{x}\)</span> input values subsequently change – i.e. if the sensory input changes – then the prediction values <span class="math inline">\(\mathbf{y}\)</span> will change too in an effort to keep up.</p>
<p>If the steps of the algorithm that governs the ANN were unfolded and written out as a list of individual instructions, we would see that what is described here is really just shorthand for a very long sequence of elementary numerical operations – repeated additions and multiplications that progressively modify the <span class="math inline">\(e_i\)</span> and <span class="math inline">\(y_j\)</span> values – to converge on the <span class="math inline">\(\mathbf{y}\)</span> that will minimise the sum of the squares of the <span class="math inline">\(\mathbf{e}\)</span> values for a given <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{W}\)</span>. An ANN with all its units and connections is no more than a statement of a series of additions and multiplications that should be applied in response to – or, given that the ANN commences with certain <span class="math inline">\(\mathbf{y}\)</span> values, <em>in anticipation of</em> – any input.</p>
<h2 data-number="2.3" id="the-learning-algorithm"><span class="header-section-number">2.3</span> The learning algorithm</h2>
<p>ANNs can run in two modes: <em>inference</em> or <em>learning</em>. What has been described so far is the network running in inference mode. In inference mode, connection weights, <span class="math inline">\(\mathbf{W}\)</span>, are assumed to be fixed and the <span class="math inline">\(\mathbf{y}\)</span> activation levels are varied – by repeated application of the activation function – to minimise the prediction error. In learning mode, <span class="math inline">\(\mathbf{x}\)</span> inputs and <span class="math inline">\(\mathbf{y}\)</span> prediction values are assumed to be fixed, and the connection weights, <span class="math inline">\(\mathbf{W}\)</span>, are varied – by repeated application of a ‘learning rule’ – to minimise the prediction error over those <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{y}\)</span> values. When engaged in inference, the computational system varies its <em>prediction values</em> (<span class="math inline">\(\mathbf{y}\)</span>) to try to make its prediction (<span class="math inline">\(\mathbf{Wy}\)</span>) approximate the actual sensory input <span class="math inline">\(\mathbf{x}\)</span>. When engaged in learning, the system varies its <em>generative model</em> (<span class="math inline">\(\mathbf{W}\)</span>) to try to make its prediction (<span class="math inline">\(\mathbf{Wy}\)</span>) approximate the sensory input <span class="math inline">\(\mathbf{x}\)</span>. Advocates of predictive coding are generally keen to stress that for both inference and learning the computational task is the same: namely, to minimise sensory prediction error.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>An ANN cannot run in both inference and learning modes at the same time. Attempting to simultaneously vary both <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> to minimise prediction error would turn the error-minimisation task into an ill-posed problem. If an ANN is searching for <span class="math inline">\(\mathbf{y}\)</span> values using the rules described in Section 2.2, some set of weights <span class="math inline">\(\mathbf{W}\)</span> need to be assumed; if it is searching for <span class="math inline">\(\mathbf{W}\)</span> values to minimise its prediction errors, some set of <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{y}\)</span> values need to be assumed. If neither factor is held fixed, the system would not know whether or by how much to change its prediction values, <span class="math inline">\(\mathbf{y}\)</span>, or its predictive model, <span class="math inline">\(\mathbf{W}\)</span>, in response to a prediction error.</p>
<p>Advocates of predictive coding deal with this problem by assuming that the ANN performs inference and learning on different timescales. Over ‘short’ timescales (assumed to be of the order of hundreds of milliseconds for the brain), the ANN runs in inference mode, settling into the <span class="math inline">\(\mathbf{y}\)</span> values that minimise prediction error for some given <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(\mathbf{W}\)</span>. Over ‘long’ timescales (assumed to be of the order of seconds, minutes, days, or years for the brain), many <span class="math inline">\(\mathbf{x}, \mathbf{y}\)</span> values are assumed and a <span class="math inline">\(\mathbf{W}\)</span> (generative model) is sought that minimises prediction error over those pairs. If one sets aside any assumptions about physical implementation and considers what is being proposed only within the idealised world of numerical algorithms, the idea is that the learning rule should be applied to a network’s connection weights once its prediction values <span class="math inline">\(\mathbf{y}\)</span> have settled into a relatively stable state after one or more episodes of inference have run to completion for a given set of <span class="math inline">\(\mathbf{x}\)</span> values. It is assumed that episodes of inference will in general complete comparatively quickly, and that updating of connection weights (learning) can occur in the pauses between inference.</p>
<p>Predictive coding proposes that the network uses a <em>Hebbian learning rule</em>. This specifies that, at each computational step during learning, the ANN should change a connection’s weight in proportion to the current activation levels of the two units that it connects. The rule provides a step-by-step mathematical procedure by which to change connection weights, <span class="math inline">\(\delta w_{i,j} = \eta e_{i} y_{j}\)</span>, where <span class="math inline">\(\delta w_{i,j}\)</span> is how much a connection weight <span class="math inline">\(w_{i, j}\)</span> should change each step, <span class="math inline">\(e_i\)</span> and <span class="math inline">\(y_i\)</span> are the activation levels of the error and prediction units linked by the connection, and <span class="math inline">\(\eta\)</span> is a constant value that sets how rapidly connection weights change during learning (the ‘learning rate’ for the network). It is possible to show that if a Hebbian learning rule is applied to an ANN shown in Figure 1, the network will tend to converge on connection weights <span class="math inline">\(\mathbf{W}\)</span> that minimise prediction error over its past inputs and predictions.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> Hebbian learning represents a different approach to learning to the ‘backpropagation’ rules that are currently popular in the AI community and which are utilised to great success by deep learning systems <span class="citation" data-cites="LeCunBengioHinton15">(LeCun et al. 2015)</span>. A Hebbian learning rule is regarded as attractive in this context because it makes learning depend only on local interactions between units, which is regarded as a more realistic model of the forms of plasticity found in the brain <span class="citation" data-cites="Bogacz17">(Bogacz 2017 p. 199)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<p>As with the activation function that governs inference, the Hebbian rule that governs learning should be viewed as a series of elementary mathematical steps. It reduces learning to a long sequence of numerical operations. Learning for predictive coding consists – at least at the algorithmic level – in a series of additions and multiplications on the elements of <span class="math inline">\(\mathbf{W}\)</span>. It is worth noting that inference and learning do not reduce to <em>exactly</em> the same computational task on this model. The sensory prediction errors minimised during inference are the <em>current</em> sensory prediction errors. The sensory prediction errors minimised during learning are <em>past</em> sensory prediction errors averaged over past inputs and their associated prediction values. Neither quantity maps in any obvious way onto the not-fully-articulated, prospective measure of long-term sensory prediction error favoured by predictive coding at Marr’s computational level <span class="citation" data-cites="Sprevak20b">(see Sprevak forthcoming sec. 5)</span>.</p>
<h2 data-number="2.4" id="precision-weighting"><span class="header-section-number">2.4</span> Precision weighting</h2>
<div id="fig2">
<figure>
<img src="img/ann2.png" title="opt title" style="width:65.0%" alt="A single layer with inhibitory connections to allow precision weighting of the error signals." /><figcaption aria-hidden="true">A single layer with inhibitory connections to allow precision weighting of the error signals.</figcaption>
</figure>
</div>
<p>In the current model, each error unit <span class="math inline">\(e_i\)</span> has as much influence as any other during both inference and learning. There is no precision weighting of prediction errors. The standard way to add precision weighting to the model is to modify the ANN to add <em>lateral and intrinsic inhibitory connections</em> between error units. These allow an error unit to inhibit both itself and its peers <span class="citation" data-cites="FeldmanFriston10 Friston05">(Feldman &amp; Friston 2010 pp. 1–2; Friston 2005 p. 823)</span>. Inter-error connections selectively dampen some error units, giving them outsize importance relative to their companions. The inhibitory connections between error units effectively control the ‘gain’ of each error unit.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> Being the target of strong inhibitory connections can turn an error unit down; being the target of weak inhibitory connections tends to turn an error unit up. The weights of these new inhibitory connections, <span class="math inline">\(\Sigma_{u,v}\)</span>, are captured by a matrix, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>, called the ‘precision matrix’.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a></p>
<p>The precision matrix, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>, should not be confused with the generative model, <span class="math inline">\(\mathbf{W}\)</span>. The generative model, <span class="math inline">\(\mathbf{W}\)</span>, records how much each prediction value contributes to the sensory prediction, <span class="math inline">\(\mathbf{r}\)</span>; the precision matrix, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>, records how much each component of the sensory prediction error, <span class="math inline">\(\mathbf{e}\)</span>, is dampened. Introducing weighted connections between error units effectively creates a new degree of freedom for how sensory prediction error might be minimised when the ANN runs. Potentially, a prediction error can be reduced by changing the prediction values (<span class="math inline">\(\mathbf{y}\)</span>), changing the generative model (<span class="math inline">\(\mathbf{W}\)</span>), or by changing the precision weighting over the error signal (<span class="math inline">\(\boldsymbol{\Sigma}\)</span>) to selectively dampen certain components of the signal. Minimising sensory prediction error thus involves, not just changes to two parameters, <span class="math inline">\(\mathbf{y}\)</span>, <span class="math inline">\(\mathbf{W}\)</span>, but potentially changes to three parameters, <span class="math inline">\(\mathbf{y}\)</span>, <span class="math inline">\(\mathbf{W}\)</span>, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>. The individual steps that constitute inference (which governs changes to <span class="math inline">\(\mathbf{y}\)</span> for fixed <span class="math inline">\(\mathbf{W}\)</span>) and learning (which governs changes to <span class="math inline">\(\mathbf{W}\)</span> for fixed <span class="math inline">\(\mathbf{y}\)</span>) are widely known and typically take a form similar to those described above. However, at the algorithmic level it is not immediately obvious which step-by-step procedure should govern changes to <span class="math inline">\(\boldsymbol{\Sigma}\)</span>.</p>
<p><span class="citation" data-cites="Bogacz17">Bogacz (2017)</span> suggests that the algorithm for changing <span class="math inline">\(\boldsymbol{\Sigma}\)</span> should be a Hebbian learning rule of the same kind as that which determines the changes to <span class="math inline">\(\mathbf{W}\)</span> (pp. 206–208). The virtue of this proposal is that it makes it straightforward to incorporate changes to <span class="math inline">\(\boldsymbol{\Sigma}\)</span> into predictive coding’s algorithm: connection weights, <span class="math inline">\(\Sigma_{u,v}\)</span>, should be updated according to the same rule, and at the same time, as connection weights for the generative model, <span class="math inline">\(w_{i, j}\)</span>. However, treating connection weights for the generative model and those for precision weighting of the error signal in the same way suggests that any change to precision weighting will be a relatively ‘slow’ process, one that unfolds in the same gradual, incremental way as learning. To this end, Bogacz observes that the precision matrix should be viewed as relatively stable quantity that, like the generative model, is acquired and maintained over one’s lifetime; it is not a volatile parameter, like <span class="math inline">\(\mathbf{y}\)</span>, that may change rapidly and drastically on short timescales (p. 202). This does not, however, sit well with what predictive coders say about the psychological function of precision weighting. They associate precision weighting with the allocation of the subject’s attention. This appears to place changes to precision weighting, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>, on the ‘short’ timescale of inference rather than the ‘long’ timescale of learning. Precision weighting should be capable of rapidly and dramatically reshaping the flow of information across the system to produce the psychological and behavioural effects observed in, for example, task switching or attentional capture.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> It is hard to see how these kinds of quick, transformative changes in the ANN can occur if changes to precision weighting are restricted to taking place at timescales much longer than those of inference. In other words, it is not clear how a slow, gradual, Hebbian-based learning rule could be responsible for them.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a></p>
<p><span class="citation" data-cites="KanaiKomuraShipp15">Kanai et al. (2015)</span> sketch a different procedure by which changes to <span class="math inline">\(\boldsymbol{\Sigma}\)</span> might be produced. They claim that changes to precision weighting are determined extrinsically, by a second ANN, which they provisionally locate inside the pulvinar nuclei of the thalamus <span class="citation" data-cites="Sprevak20d">(see Sprevak forthcoming sec. 6)</span>. Like with the present ANN – which they claim is physically implemented in the neocortex – this secondary ANN may be interpreted as performing a variety of message-passing subjective Bayesian inference (see Section 5). In distinction to the primary ANN however, the secondary network is arranged to perform a ‘second-order’ inference <em>about</em> the precision of (inverse of the variance of the degree of belief in) the error signals in the first ANN. The units of the two ANNs are joined by a series of connections such that the second ANN receives both predictions and prediction errors from the primary ANN, and its second-order predictions about precision weightings influence the <span class="math inline">\(\boldsymbol{\Sigma}\)</span> values of the first ANN. <span class="citation" data-cites="Hohwy12">Hohwy (2012)</span> provides an informal description of how this arrangement is supposed to work (pp. 3–4). However, the precise details of the numerical algorithm – the specific individual mathematical steps taken by the second ANN to modify the connection weights <span class="math inline">\(\boldsymbol{\Sigma}\)</span> of the first ANN – are still not clear or widely agreed.</p>
<h2 data-number="2.5" id="extending-the-algorithm"><span class="header-section-number">2.5</span> Extending the algorithm</h2>
<p>The algorithm sketched so far should be understood as only a basic skeleton that may be extended in any number of different ways. What we have described could be viewed as the most simple example of predictive coding. We assumed that each layer is governed by a linear generative model and that this model has a fixed number of parameters (<span class="math inline">\(\frac{n m}{2}\)</span>).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> There is no scope for a layer to depart from a linear generative model, grow or shrink the number of parameters (by creating or removing a prediction unit or connection), change its activation function, break the symmetrical arrangement of equal and opposite weighted connections between prediction and error units, swap the learning rule, or otherwise depart from the many assumptions hard-wired into the algorithm. It is natural to wonder whether some of these assumptions regarding how a layer tries to predict its input should be loosened or modified.</p>
<p>It is common to suggest that the simple algorithm for a single layer should be modified to introduce some non-linearity into the generative model. Friston argues that the brain approximates sensory input using a non-linear generative model in which prediction units, <span class="math inline">\(y_i\)</span>, have a non-linear influence on the error units below them, <span class="math inline">\(e_i\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> This means that changes in the activation level of error units during inference need not be proportional to changes in the activation level of their connected inputs – the input an error unit receives may depend on both lateral interactions between prediction units and on a non-linear function of their individual activation levels.</p>
<p><span class="citation" data-cites="Bogacz17">Bogacz (2017)</span> discusses several ways in which such a non-linearity might be built into the steps taken by the ANN. These include modifying the activation function of prediction or error units, or inserting additional artificial ‘inter-neurons’ with non-linear activation functions between the existing prediction and error units (p. 203). The exact nature of the non-linear function that should affect the outputs of the prediction units is also unclear. Friston interprets the connections between prediction and error units as encoding a generative probabilistic model of the sensory input (see Section 5). The required non-linear function could therefore be assumed to correspond to whatever would be necessary to encode the non-linear aspects of that probabilistic model.</p>
<p>A predictive coding algorithm need not be restricted to using a generative model with a set number of parameters. <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> suggest that the predictive coding algorithm engages, not only in inference and learning, but also in <em>model comparison</em>. Model comparison is usually regarded as a step that occurs at a level of abstraction above learning. Whereas learning assumes the system is using a generative model with a fixed number of parameters and it aims to optimise the values of those parameters relative to some objective function (e.g. to minimise prediction error), model comparison aims to find the <em>type</em> of generative model to subject to learning (e.g. would a model with <span class="math inline">\(N\)</span> or <span class="math inline">\(N+1\)</span> parameters do a better job?). The predictive coding algorithm described above does not attempt to do any model comparison. It is restricted to using a generative model with a fixed structure and with <span class="math inline">\(\frac{n m}{2}\)</span> parameters. <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> propose that the brain does something akin to model comparison, albeit slightly more sophisticated, called ‘Bayesian model averaging’.</p>
<p>Bayesian model averaging assumes that the system has not one, but many generative models and that it has a subjective probability distribution over those generative models reflecting its prior credences in those models. The agent then applies Bayes’ rule to calculate a posterior probability distribution over all its generative models given the observed data <span class="citation" data-cites="Bishop06">(Bishop 2006 pp. 161–5)</span>. At this point, the agent could conceivably elect to adopt just one generative model – perhaps the one with the highest subjective probability given the data, the ‘maximum a posteriori’ model.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> Alternatively – and this is what <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> suggest – the agent may continue to operate in a Bayesian fashion and entertain a full posterior subjective probability distribution over all its generative models and deploy this full posterior distribution in inference, updating it and revising its degree of belief in those models as more data comes in.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> The predictions that the agent generates on such a scheme would be the average of the predictions of all models weighted by the system’s posterior subjective probability in each model given the observed data.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> propose that this model averaging process occurs, not inside a single layer of predictive coding’s ANN, but in the interaction between discrete layers, with the predictions from different generative models being weighted by their different top-down influences on lower layers (ibid., p. 3). The precise implementation of this, both in terms of the specific steps that an ANN should take and its physical basis remains, however, somewhat unclear.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a></p>
<p><span class="citation" data-cites="Clark15">Clark (2016)</span> suggests that the number of parameters in the generative model might change over time because the connections between prediction and error units may be subject to some ‘pruning’ algorithm (p. 272). A pruning algorithm is a procedure that would systematically remove connections between prediction and error units that are, according to the algorithm, deemed to be redundant. Many possible pruning algorithms exist for ANNs.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a> These algorithms normally operate on a timescale that is longer than both those of inference and learning, attempting to remove connections after one or more episodes of learning are complete. It is not clear which pruning technique should apply to predictive coding’s ANN, the timescale it should run on, and how its operation would fit with <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span>’s proposal about Bayesian model comparison and Bayesian model averaging.</p>
<p>These suggestions are indicative of just a few of the ways in which the basic algorithm of predictive coding might be changed or elaborated. The research programme of predictive coding takes the basic ANN described in the preceding sections as a starting point and develops it in different ways.</p>
<h1 data-number="3" id="an-algorithm-not-an-implementation"><span class="header-section-number">3</span> An algorithm, not an implementation</h1>
<p>It is important to stress that what has been described is an <em>algorithm</em>. The ANN is sometimes called an ‘implementation’ of predictive coding.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a> This terminology is potentially misleading as there are no assumptions about physical implementation built into the model. There is no assumption, for example, that the units depicted in Figure 1 are physical neurons, that their connections correspond to synapses, or that their activation levels map in any straightforward way to neural firing rates. What has been described is a numerical procedure – a step-by-step method for modifying <em>numbers</em>. It accomplishes a task defined solely in numerical terms: to find values of <span class="math inline">\(\mathbf{y}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> that minimise <span class="math inline">\(\sum_i (x_i - r_i)^2\)</span> for a sequence of given <span class="math inline">\(\mathbf{x}\)</span> (that we have labelled, without further justification, ‘sensory input’).</p>
<p>Despite its name, an artificial neural network is no more neural than any other algorithm, such as QuickSort, the Newton–Raphson algorithm for finding roots of real-valued functions, or the Runge–Kutta algorithm for finding solutions to ordinary differential equations. The prediction and error units and connections shown in Figure 1 may, in some loose sense, be suggestive of neural structures in the brain. But it should be clear that what is proposed here is only a numerical method for solving a numerical problem – effectively, a long sequence of elementary additions and multiplications that would enable someone without insight or ingenuity to estimate one set of values (<span class="math inline">\(\mathbf{x}\)</span>) with another set of values (<span class="math inline">\(\mathbf{y}\)</span>, <span class="math inline">\(\mathbf{W}\)</span>, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>). These operations could easily be implemented in any number of pieces of hardware, including very un-brain-like hardware, such as an electronic PC.</p>
<p>What advocates of predictive coding are likely to mean when they describe the ANN as an implementation of predictive coding is that the algorithm in question is <em>biologically plausible</em> – it is the kind of algorithm that <em>could</em> be implemented in a brain. It is based around numerical states and procedures – a network-like structure, vector-based computational states, and Hebbian learning – that lend themselves to neural implementation.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> However, the possibility of neural implementation does not mean that what has been described <em>is</em> a neural implementation. What is proposed at the algorithmic level by predictive coding is a sequence of abstract numerical operations to accomplish a computational task that has been characterised as a numerical problem. Precisely how these operations map onto the hardware of the brain, or onto the informal task description of a real-world agent minimising its sensory prediction error, is a separate issue and one that we will turn to later <span class="citation" data-cites="Sprevak20d">(see Sprevak forthcoming)</span>.</p>
<h1 data-number="4" id="hierarchical-structure"><span class="header-section-number">4</span> Hierarchical structure</h1>
<p>A single layer attempts to predict its sensory input using a model, <span class="math inline">\(\mathbf{W}\)</span>, each of whose variables, <span class="math inline">\(y_i\)</span>, makes an independent contribution to the prediction. This kind of model makes sense if each variable of the model aims to track an independent feature of the input. However, many worldly features that are useful to track for prediction are not structured in this way. Often they stand in a hierarchical relationship to each other. For example, the <em>general category</em> of an encountered object (e.g. living thing, inanimate object) constrains the <em>specific type</em> of object it is (human being, cat, dog), which further constrains its <em>identity</em> (your father, Tiddles the cat). These are not three independent features in the world, but ones that stand in a well-defined relationship to each other. They should not be modelled by three variables with no inherent structure, but by variables that somehow capture the hierarchical relationship between their corresponding features.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a></p>
<p>A rich source of hierarchical relations between worldly features derives from features that occur on different spatial and temporal scales. The brain tracks sensory information at multiple spatiotemporal levels and information at one spatiotemporal scale helps constrain the brain’s hypotheses at another.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a> The visual system, for example, tracks large-scale, ‘gist’-like features – e.g. whether it is facing a jungle, desert, or underwater scene – as well as small-scale, ‘detail’-like features – e.g. whether a particular patch of colour is green, red, or blue. The external features that generate our sensory input are structured in a hierarchical fashion over multiple spatiotemporal scales. A plausible strategy for an accurate predictive model would be to aim to mirror that structure inside the model. Rao and Ballard summarise the rationale as follows:</p>
<blockquote>
<p>The underlying assumption here is that the external environment generates natural signals hierarchically via interacting hidden physical causes (object attributes such as shape, texture and luminance) at multiple spatial and temporal scales. The goal of a visual system then becomes optimally estimating these hidden causes at each scale for each input image and, on a longer time scale, learning the parameters governing the hierarchical generative model. <span class="citation" data-cites="RaoBallard99">(Rao &amp; Ballard 1999 p. 80)</span><a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a></p>
</blockquote>
<p>Despite their focus on causal structure, there is nothing specifically causal about the point Rao and Ballard make about the benefits of using a hierarchical model for prediction. <em>Any</em> hierarchical relationship between external properties in the world – be that a hierarchy induced by a causal structure or one that arises for any other reason, e.g. due to the relationship between determinables and determinates or between types and tokens – might profitably be modelled by a model that reproduces the hierarchy amongst the variables that track them.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a></p>
<div id="fig3">
<figure>
<img src="img/ann3v2.png" title="opt title" style="width:100.0%" alt="Hierarchical predictive coding according to two different schemes for dividing the ANN into layers. Rao and Ballard’s scheme is shown on the left-hand side; Spratling’s is shown on the right-hand side. Single prediction and error units inside each layer (circles in the previous diagram) are omitted for simplicity adapted from, p. 95(adapted from Spratling 2017 p. 95)" /><figcaption aria-hidden="true">Hierarchical predictive coding according to two different schemes for dividing the ANN into layers. Rao and Ballard’s scheme is shown on the left-hand side; Spratling’s is shown on the right-hand side. Single prediction and error units inside each layer (circles in the previous diagram) are omitted for simplicity <span class="citation" data-cites="Spratling17">(adapted from Spratling 2017 p. 95)</span></figcaption>
</figure>
</div>
<p>The predictive coding algorithm encodes relationships between variables using a hierarchy of interlinked generative models. It consists of a stack of multiple ANNs, each identical to that described in Section 2, connected to each other. Each error unit of a layer (<span class="math inline">\(e_i\)</span>) connects to a prediction unit in the layer below (<span class="math inline">\(y_i\)</span>). So defined, the computational task of a single layer of the ANN is to predict the activation levels of the prediction units inside the layer below (the output of that lower layer serves as its ‘sensory input’). Activation levels of prediction units in layers that are increasingly distant from sensory input will tend to track more abstract, high-level features in the sensory input.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a> The bottom-most layer has no prediction units below it; its inputs are clamped to some externally supplied sensory input, <span class="math inline">\(\mathbf{x}\)</span>, as shown in Figure 1. The entire stack of layers will adjust the activation levels of prediction units, <span class="math inline">\(y_i\)</span>, during inference to minimise sensory prediction errors, <span class="math inline">\(e_i\)</span>, via gradient descent, with each layer operating to minimise the prediction error about the prediction values of the layer below. When the network is allowed to run, activation levels will evolve to minimise prediction error concerning the external sensory signal, <span class="math inline">\(\mathbf{x}\)</span>, consistent with minimising prediction error at each level of the model’s hierarchy.</p>
<p>From the point of view of a single layer, the primary change from the model previously described is the introduction of new connections between layers (denoted by vertical lines in Figure 3). These connections allow the predictions at one level of the predictive hierarchy to influence (via the intervening error units) the predictions at other levels. Unlike the weighted connections inside a layer, which are used to encode the generative model, these new connections between layers are of a constant, equal weight and they are not subject to modification by learning. Each error unit is assumed to connect to exactly one prediction unit in the layer below – i.e. each component of <span class="math inline">\(\mathbf{e}^{Si}\)</span> is connected, by reciprocal excitatory and inhibitory connections, to a single component of <span class="math inline">\(\mathbf{y}^{Si}\)</span>. Given this arrangement, each error unit will measure the <em>prediction error</em> for its counterpart prediction unit in the layer below (or, for the bottom-most layer, the error in predicting the corresponding component of the sensory input, <span class="math inline">\(\mathbf{x}\)</span>).</p>
<p>To see why the new connections do this, consider the <span class="math inline">\(S1\)</span> error units in Figure 3. Their activation levels are a function of just two factors: (i) excitatory inputs they receive from prediction units in the layer below (<span class="math inline">\(\mathbf{y}^{S1}\)</span>); (ii) inhibitory inputs they receive from the layer’s own prediction units filtered through the connection weights of the model (<span class="math inline">\(\mathbf{Wy}^{S2}\)</span>). The net activation level of the <span class="math inline">\(S1\)</span> error units is thus:</p>
<p><span class="math display">\[
\mathbf{e}^{S1} = \mathbf{y}^{S1} - \mathbf{Wy}^{S2}
\]</span></p>
<p>The error units <span class="math inline">\(\mathbf{e}^{S1}\)</span> signal the difference between (i) the actual activation level of the prediction units inside the layer below (<span class="math inline">\(\mathbf{y}^{S1}\)</span>) and (ii) a ‘prediction’ about those levels generated by the prediction units from above (<span class="math inline">\(\mathbf{Wy}^{S2}\)</span>). If these two quantities were to match exactly, then the <span class="math inline">\(\mathbf{e}^{S1}\)</span> units would be silent. If the discrepancy between these two quantities were to increase, so would the activation level of the <span class="math inline">\(\mathbf{e}^{S1}\)</span> units. The error units provide a measure of <em>prediction error</em> – the prediction values minus the layer’s estimate of those prediction values based on its generative model.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a></p>
<p>Figure 3 omits the inhibitory connections, <span class="math inline">\(\boldsymbol{\Sigma}\)</span>, between error units that encode precision weighting. However, these can be straightforwardly incorporated into the ANN. With respect to the equation above, this would involve introducing a normalisation term that modulates the response of the error units in proportion to their relative precision weighting. If the inhibitory connections, <span class="math inline">\(\boldsymbol{\Sigma}_{S1}\)</span>, were added, the error units in <span class="math inline">\(S1\)</span> would signal <em>precision-weighted prediction error</em>, <span class="math inline">\(\mathbf{e}^{S1} = \boldsymbol{\Sigma}_{S1}^{-1} ( \mathbf{y}^{S1} - \mathbf{Wy}^{S2} )\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a></p>
<p>The hierarchical ANN for predictive coding is governed by exactly the same rules for inference and learning as those for the single layer described in Section 2. The activation function and the Hebbian learning rule are applied to every unit and weighted connection in the network as inference and learning proceed. The generative models encoded in the connections linking prediction and error units, since they are used at the same time, may be viewed as components of one giant, overarching, hierarchical generative model. Like with other ANNs, the pictured ANN is no more than a compact, finite mathematical formalism that prescribes a long sequence of additions and multiplications. What advocates of predictive coding mean by proposing this model is that this sequence would take anyone that follows it from one set of numerical values <span class="math inline">\(\mathbf{x}\)</span>, to a series of ‘prediction value’ vectors (<span class="math inline">\(\mathbf{y}^{Si}\)</span>) and ‘generative model’ matrices (<span class="math inline">\(\mathbf{W}^{Si}\)</span>), such that when the prediction values are combined with the generative model according to the rules above, the <span class="math inline">\(\mathbf{x}\)</span> are reconstructed as accurately as possible, given that what counts as ‘accuracy’ is modulated by a further set of values, the ‘precision weightings’ (<span class="math inline">\(\boldsymbol{\Sigma}_{Si}\)</span>).</p>
<p>The formal model described so far is based on Spratling’s <span class="citation" data-cites="Spratling17">(2017)</span> account of hierarchical predictive coding. According to Spratling, a <em>single layer</em> of the hierarchical ANN is a set of prediction and error units connected by weighted connections (i.e. <span class="math inline">\(\mathbf{y}^{Si+1}\)</span> and <span class="math inline">\(\mathbf{e}^{Si}\)</span> form a layer). The function of a layer of the hierarchy, so defined, is to <em>predict the activation levels of the prediction units in the layer below</em>. Its success or failure in this is tracked by the activation levels of the layer’s own error units. Given this assumption, the connections <em>inside</em> a layer have a relatively complicated structure – their weights encode a generative model and are subject to change during learning. In contrast, the connections <em>between</em> layers have a relatively simple structure and are not subject to change by learning. The function of the connections between layers is to <em>compute the prediction error</em>, as described by the equation above. Consequently on Spratling’s view, the outputs of a ‘layer’ are: (i) its prediction values, <span class="math inline">\(y_i\)</span>, which are passed <em>up</em> the hierarchy to the layer above; (ii) its prediction error values, <span class="math inline">\(e_i\)</span>, which are passed <em>down</em> the hierarchy to the layer below. In short, error signals will flow <em>downwards</em> and prediction values will flow <em>upwards</em> between layers.</p>
<p>The hierarchical model first proposed by <span class="citation" data-cites="RaoBallard99">Rao &amp; Ballard (1999)</span> and subsequently developed by <span class="citation" data-cites="Friston05">Friston (2005)</span>, <span class="citation" data-cites="Friston08">Friston (2008)</span>, and <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span> operates with a different conception of a hierarchical layer. For Spratling a ‘layer’ means a set of prediction and error units connected by weighted connections. For Rao and Ballard, it means a set of prediction and error units that stand in one-to-one relationship to each other (i.e. <span class="math inline">\(\mathbf{y}^{Si}\)</span> and <span class="math inline">\(\mathbf{e}^{Si}\)</span> form a layer). The function of a layer of the hierarchy, so defined, is to <em>compute the prediction error</em>. The error units subtract the prediction made by the layer above from the prediction values held inside the layer, as described by the equation above. Given this assumption, the connections <em>inside</em> a layer have a relatively simple structure and are not subject to change by learning. In contrast, the connections <em>between</em> layers have a relatively complicated structure – their weights encode a generative model and are subject to change during learning. On Rao and Ballard’s view, the outputs of a ‘layer’ are: (i) its prediction values, <span class="math inline">\(y_i\)</span>, which are passed <em>down</em> the hierarchy to the layer below; (ii) its prediction error values, <span class="math inline">\(e_i\)</span>, which are passed <em>up</em> the hierarchy to the layer above. In short, error signals will flow <em>upwards</em> and prediction values will flow <em>downwards</em> between layers.</p>
<p>It is important to emphasise that these two proposals, considered purely as numerical methods, are identical. They agree about which mathematical steps should be taken, when they should taken, and in what order. Their point of disagreement concerns only how to <em>label</em> features of the ANN as ‘layers’. Which method of labelling one favours makes no difference to the step-by-step operation of the abstract algorithm. This difference does, however, have consequences when it comes to making claims about the neural implementation of the algorithm. These claims involve mapping labelled parts of the algorithm (e.g. layers) onto discrete brain structures (e.g. cortical areas). We will explore how these two notions of layer affect claims about neural implementation in <span class="citation" data-cites="Sprevak20d">Sprevak (forthcoming)</span>, Section 3.</p>
<h1 data-number="5" id="representing-probabilistic-guesses"><span class="header-section-number">5</span> Representing probabilistic guesses</h1>
<p>In the preceding sections, I described the predictive coding algorithm as a numerical method that takes a set of numbers (‘sensory input’) and finds two sets of numbers (‘prediction values’ and ‘generative model parameters’) that, if combined, would reconstruct the first set as accurately as possible relative to some agreed (precision weighted) error measure. However, these formal steps are frequently accompanied by an <em>interpretation</em> that connects the numbers to features that matter to the brain in cognition. The numerical values are meant to be understood not simply as abstract numbers; they should also be linked in some way to the informally characterised task that the brain faces of minimising its sensory prediction error. Interpretations have already been hinted at by the labels we assigned to these values (‘sensory input’, ‘prediction’, etc.), but there is more to say here.</p>
<p>One might distinguish between interpretations of predictive coding’s algorithm that are representation-<em>light</em> – that do not assume that the algorithm is a process defined over representations – and those that are representation-<em>heavy</em> – that do assume that the algorithm is a process defined over representations.</p>
<p>According to a representation-<em>light</em> interpretation of the algorithm, the numbers correspond to certain physical quantities of functional significance to the brain in cognition. Precisely which physical quantities would be specified by what predictive coding says at the implementation level <span class="citation" data-cites="Sprevak20d">(Sprevak forthcoming)</span>. One might, for example, suggest that the magnitude of the <span class="math inline">\(\mathbf{x}\)</span> values measures the firing rate of certain neurons at the sensory periphery; the magnitude of the <span class="math inline">\(\mathbf{y}\)</span> values measures of the firing rate of certain populations of cortical neurons; and the magnitude of the <span class="math inline">\(\mathbf{W}\)</span> values measures the strength of synaptic connections between those populations of cortical neurons. Given this interpretation, the algorithm describes not just abstract relationships between numbers, but also how cortical neurons cooperate to suppress incoming sensory signals.</p>
<p>If one adopts this interpretation, then when one says that the brain issues a ‘prediction’, there need be no suggestion that the brain <em>represents</em> that sensory signal, that it has a hypothesis ‘about’ it. The interpretation does not commit to the algorithm involving content-bearing, semantically evaluable states – ‘representations’ as normally conceived. A ‘prediction’ on this reading is not like a weather report that provides a prediction <em>about</em> tomorrow’s weather. Instead, it would ‘predict’ in the same sense that the seat of your chair ‘predicts’ the downward force exerted by your body: by cancelling it out, or quenching it. The predictive coding algorithm describes how certain physical magnitudes in the brain (quantified by <span class="math inline">\(\mathbf{y}\)</span> values) combine with other physical magnitudes (quantified by <span class="math inline">\(\mathbf{W}\)</span> values), to cancel out further physical magnitudes near the sensory boundary (quantified by the <span class="math inline">\(\mathbf{x}\)</span> values). ‘Prediction’ should be understood as a process of brute matching of incoming physical signals at sensory neurons. If a prediction is ‘successful’, that would mean that the brain’s internally generated physical signals successfully counterbalance those at the sensory boundary caused by the world.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> Precisely which physical quantities are in balance – which aspects of brain function map onto which numerical values of the algorithm – will depend on what is said by predictive coding at Marr’s implementation level. However, the basic idea – which might be fleshed out in many different ways – is that the numbers and mathematical operations in the algorithm should be understood as useful ways of describing the <em>dynamics of physical brain activity</em>. Such an interpretation of predictive coding’s algorithm is notably silent about whether any representations are manipulated during that physical process.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a></p>
<p>A representation-<em>heavy</em> reading assumes that the algorithm describes, <em>not only</em> the physical dynamics of brain activity, but <em>also</em> how representations are processed during cognition. In this case, a ‘prediction’ should be understood, at least roughly, on the model of a weather report. A prediction is associated with both a <em>physical magnitude</em> (as specified by the account of implementation) and a <em>semantic content</em>. It makes sense to ask what a prediction is ‘about’, what it refers to in the world. The numerical states and operations of the algorithm should be understood as describing not only physical dynamics, but also a kind of semantically rich <em>inference</em>. Representations are manipulated according to steps determined by the algorithm and that inference may be evaluated as conforming (or not) to various norms. It is not unusual for computer algorithms to be interpreted in this way. A chess-playing algorithm, for example, is often interpreted as requiring changes not only in the physical states of any machine that implements it, but also the manipulation of <em>representations</em> of chess pieces and chess positions in such a way that conforms to the norms that govern the game of chess.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a></p>
<p>The dominant representation-heavy interpretation of the predictive coding algorithm treats that algorithm as describing a form of <em>probabilistic inference</em> <span class="citation" data-cites="Bogacz17 Friston05 Friston09 Friston10">(Bogacz 2017; Friston 2005, 2009, 2010)</span>. On this view, the representations being manipulated are subjective probabilities (probabilistic representations) and the process described by the algorithm is a form of approximate Bayesian inference. The key assumption of this interpretation is that the numerical <em>activation levels</em> and <em>weights</em> of the ANN units and connections encode the <em>sufficient statistics of subjective probability distributions</em>. These subjective probability distributions are the brain’s subpersonal guesses or hypotheses about the values of various hidden variables in the environment (e.g. shapes, sizes, locations, and identities of environmental objects). These subjective probability distributions are combined during inference – according to the step-by-step rules described by the algorithm that progressively modify the values that correspond to their sufficient statistics – to generate a prediction about the sensory signal. Just as a classical computer algorithm – that applies symbolic rules to symbolic expressions – provides a way to automate deductive inference, so an ANN – that applies simple mathematical operations to numbers – provides a way to automate probabilistic inference. Given the right interpretation, an ANN with the appropriate structure can be viewed as a probabilistic inference engine.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a></p>
<p>One of the main assumptions adopted by this representation-heavy interpretation of predictive coding is that the brain’s <em>marginal</em> subjective probability distributions – its subpersonal guesses marginalised over specific variables – are always Gaussian, and so they can be fully characterised by just two numerical values, a mean and variance. The mean is assumed to be encoded by the activation level of an individual prediction unit, <span class="math inline">\(y_i\)</span>. The variance is assumed to be encoded in the weight of the intrinsic inhibitory connection of the prediction unit’s corresponding error unit, <span class="math inline">\(\Sigma_{i,i}\)</span>. The covariance between marginal distributions (<span class="math inline">\(y_i\)</span>, <span class="math inline">\(y_j\)</span>) is encoded by the weights of lateral connections between their corresponding error units, <span class="math inline">\(\Sigma_{i,j}\)</span>. The conditional probabilities that determine how marginal distributions are combined in inference are encoded by the connection weights between prediction and error units, <span class="math inline">\(w_{i,j}\)</span>. If one interprets the numbers in the ANN in this fashion, the step-by-step operations of the ANN’s algorithm can be shown to implement a message-passing form of Bayesian inference over a graphical probabilistic model. Predictions (<span class="math inline">\(\mathbf{Wy}\)</span> values) in higher layers of the ANN’s hierarchy can be shown to act as priors on subjective probabilities (<span class="math inline">\(\mathbf{y}\)</span>) in lower layers.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a></p>
<p>We saw in Section 2.5 that there is no single, agreed algorithm for predictive coding. Different proposals might be developed about the precise structure of the ANN, the activation functions of its units, and the learning rule that governs its weighted connections. There is also scope for different proposals about how to interpret an ANN’s numerical elements as encoding subjective probability distributions, and consequently about exactly what kind of probabilistic inference the ANN should be interpreted as performing. There is widespread agreement that predictive coding’s ANN should be interpreted as performing some form of <em>message-passing</em> probabilistic inference over a probabilistic graphical network.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a> The nodes, edges, and numerical values of that graphical probabilistic model should correspond in some (ideally simple!) way to the structure of the ANN and its processing. But exactly how the probabilistic graphical model maps onto the structure of the ANN, and exactly which message-passing algorithm is performed, is not clear. The substance of a representation-heavy interpretation will therefore depend on both the details of the ANN in question and on the exact scheme for how the numerical values of ANN are mapped onto subjective probability distributions. As with representation-light options, there is scope here for different ideas. <span class="citation" data-cites="FristonParrVries17">Friston, Parr, et al. (2017)</span> and <span class="citation" data-cites="ParrMarkovicKiebel19">Parr et al. (2019)</span> review a range of options, including algorithms that perform variational message passing (a message-passing version of variational Bayes) and belief propagation (a message-passing form of exact Bayesian inference).</p>
<p>On a representation-light interpretation, the ANN describes the physical dynamics of the brain as it inhibits incoming sensory signals. On a representation-heavy interpretation, the ANN describes, in addition, a form of probabilistic reasoning over subpersonal hypotheses entertained by the brain about its environment. Predictive coders often move freely between representation-light and representation-heavy formulations of their algorithm. It is fair to say that it is an open question whether predictive coding <em>should</em> be interpreted in a representation-heavy way or not. Complicating the issue is a lack of clarity about how <em>any</em> ascription of subpersonal subjective probabilities to the brain should be understood in cognitive neuroscience – whether such probabilistic representations are ‘really there’ in the brain or whether talk of them is just a useful <em>façon de parler</em> for us to interpret and group together neural activity.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a> These foundational issues about neural representation are however, to an extent, orthogonal to the specifics of predictive coding’s algorithmic-level proposal. That proposal is, in principle, compatible with a range of different views regarding how we understand representation in the brain, including viewing it as performing a highly specific form of subjective Bayesian inference or remaining neutral about whether it performs any semantically rich inference at all.</p>
<h1 data-number="6" id="going-beyond-perception"><span class="header-section-number">6</span> Going beyond perception</h1>
<p>The algorithm described in this article was originally proposed as a model of perceptual classification in the early visual system <span class="citation" data-cites="RaoBallard99">(Rao &amp; Ballard 1999)</span>. Understood this way, the algorithm takes raw sensory data as input and classifies these data into basic visual features based on a multi-layered artificial neural network. Subsequently, the predictive coding research programme has gone on to suggest that this algorithm is of much wider significance to neural function. It should be treated, not just as a model of perceptual classification in the early visual system, but potentially as a model of <em>all</em> cognitive processing. In its most ambitious form, the claim is that a single, giant ANN, like that pictured in Figure 3, is the computational engine behind all aspects of cognition <span class="citation" data-cites="Friston10">(Friston 2010 p. 130)</span>. Under Friston’s representation-heavy interpretation of the ANN, this would mean that every cognitive process could be viewed as a Bayesian inference over a single, hierarchical, probabilistic generative model <span class="citation" data-cites="Clark13">(Clark 2013 pp. 194, 198)</span>.</p>
<p>In <span class="citation" data-cites="Sprevak20b">Sprevak (forthcoming)</span>, we saw that one respect in which predictive coding offers a grand, unified theory of cognition is that it claims that a single computational <em>task</em> is faced by the brain in every domain of cognition – namely, the task of minimising sensory prediction error. Advocates of predictive coding are often also attracted to the idea that predictive coding offers a grand, unified theory of cognition in another, quite separate, respect. This is that a single type of abstract computational <em>method</em> is used by the brain to solve its task – namely, some (more sophisticated) version of the ANN pictured above. On this view, cognition would not only have a single, unified <em>objective</em>; the brain would also attempt to reach that objective by a single <em>means</em>.</p>
<p>This goal of providing a process-level unification of cognition is clearly aspirational. As we saw in Section 2.5, important elements of predictive coding’s algorithmic-level theory remain to be spelled out, and this could be done in many different ways. Furthermore, anyone who wishes to defend the process-level unification would need to show that their algorithmic-level claim successfully models, not only cognitive processes inside the early visual system, but all aspects of cognition (including motor control, decision making, causal inference, executive function, and so on). Whether predictive coding can succeed – at the algorithmic level – as a grand, unified theory depends on the extent it can successfully be applied to cognitive processes outside early vision.</p>
<p>The challenge is structurally similar to that faced by predictive coding at Marr’s computational level, as discussed in Section 7 of <span class="citation" data-cites="Sprevak20b">Sprevak (forthcoming)</span>. In that case, the problem was to show that a single <em>task description</em> (originally proposed for early vision) can and should describe every problem the brain faces in cognition. In the present case, the problem is to show that a single <em>algorithm</em> (also originally proposed for early vision) can and should describe every cognitive process. Neither challenge is likely to admit of quick or easy resolution; both should be viewed as issues that set the long-term agenda of a research programme. The two challenges are also distinct. Even if the computational-level claim were established – if it were shown that every task the brain faces can and should be described as minimising sensory prediction error – it would still be an open question whether the brain uses the same method to tackle that task in every case. A brain could conceivably use a range of computational techniques to minimise its sensory prediction errors. The ANN might be representative of only one of these. Advocates of predictive coding – even if they agree about the universal scope of the computational-level claim – may disagree about how far, and to exactly which cases, its algorithmic-level proposal should be applied outside the original domain of processing in early vision.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a></p>
<p>As with its computational-level proposal, predictive coding needs to demonstrate both the <em>empirical adequacy</em> and <em>explanatory superiority</em> of its algorithmic-level proposal relative to other algorithmic-level proposals. It needs to show that cognitive processing outside early vision – e.g. in motor control, decision making, planning, and so on – can and should be treated as following the steps of the ANN above. The next section describes how predictive coding applies the hierarchical ANN to motor control. More difficult for predictive coding to accommodate at the algorithmic level are <em>high-level</em> cognitive processes such as logical reasoning, causal reasoning, inductive inference, long-term planning, and executive control. It is simply not obvious how to get the ANN above (or indeed any ANN) to simulate these processes in a way that achieves human-like levels of performance.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a></p>
<h2 data-number="6.1" id="example-of-motor-control"><span class="header-section-number">6.1</span> Example of motor control</h2>
<p>At first glance, motor control might seem an unlikely candidate for explanation in terms of the operation of the ANN. The pictured ANN for predictive coding has ‘sensory inputs’, but no outward-facing connections labelled ‘motor outputs’. One might assume that the ANN sits exclusively on the ‘perception’ side of cognition and that it needs to be connected to some separate computational system that deals with ‘motor control’. However, advocates of predictive coding have offered an ingenious proposal for how a single ANN could simultaneously govern both perception and motor control.</p>
<p>This proposal is based around the idea that proprioceptive sensory inputs are connected to muscles via classical reflex arcs. When prediction errors cause these reflex arcs to fire, they automatically produce movement. According to the model, activity in the ANN follows the rules of inference and learning previously described and unfolds with the objective of minimising sensory prediction error. That sensory prediction error will be the precision-weighted average of every component of prediction error across all the cognitive system’s sensory channels (visual, auditory, interoceptive, proprioceptive, and so on).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a> In the proposed model of motor control, the proprioceptive input channels play a special role. If the computational system makes a prediction regarding the position of its limbs (e.g. that its left hand is holding a glass of water), then that prediction will have proprioceptive sensory consequences. If the predicted proprioceptive sensory consequences do not match the actual proprioceptive input signals (perhaps because the fingers are not touching the glass), then there will be proprioceptive sensory prediction errors. If the proprioceptive prediction error units are active (and not dialled down by a low precision weighting), then the attached muscular reflex arcs will fire, causing the corresponding muscles to which they are connected to contract. Those muscles will cause the fingers around the glass to close, which will reduce the proprioceptive prediction error, making the previously false proprioceptive prediction true, reducing the signal for that reflex arc to fire further. In this way, sensory prediction errors concerning proprioceptive inputs have the ability to bring about motor action. In this context, a sensory prediction concerning proprioception may function, not as a passive prediction of incoming signals, but like a motor command.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a></p>
<p>Many questions remain about how this is supposed to work. An important set of worries surround how one should understand the <em>direction of fit</em> of predictions inside the ANN. A cognitive agent is normally assumed to have two functionally distinct types of internal state. These may be called <em>belief-like</em> and <em>desire-like</em> state (or, on a probabilistic model, <em>credences</em> and <em>utilities</em>).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a> Roughly speaking, the former type of state keeps track of how the world is for the agent; the latter records what the agent aims for in its actions. According to the proposal above, both types of function state map onto a single kind of formal state in the ANN. Predictions serve <em>both</em> as the ANN’s estimation of how the world is <em>and</em> also how it desires the world to be. In the example just described, the ANN predicts that it is holding a glass of water. It maintains this false prediction instead of revising it in light of the countervailing sensory evidence. Because the prediction is clamped, it can be used to drive reflex arcs which activate motor neurons so that the agent will grasp the glass. In a different scenario, the ANN might issue the same prediction – that it is holding a glass of water – but revise that prediction in light of its sensory evidence to reflect the reality that it is not currently holding the glass. In the first case, the prediction has a desire-like direction of fit – it is held fixed and not revised even if the world does not conform. In the second case, the prediction has a belief-like direction of fit – it aims to track the world and should be updated based on incoming sensory signals (either by changing the prediction values or by changing the parameters of its generative model).</p>
<p>How does this dual role for prediction fit into the algorithm described above? What makes a state of the ANN have a belief-like character rather than a desire-like one? In other words, how does the ANN know when to <em>hold its prediction values and generative model fixed</em> to effect motor control versus when to <em>revise its prediction values or generative model</em> to improve the accuracy of its model? <span class="citation" data-cites="Clark15">Clark (2016)</span> suggests that there is a delicate balance between the two modes of minimising sensory prediction error during cognitive processing (p. 124). But how does that balance operate? On the basis of what rule does the formal system ‘know’ whether a prediction should be treated in one way rather than the other?<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a> The predictive coding literature offers two main answers to this question, neither of which is entirely satisfactory.</p>
<p>The first suggestion is that the <em>type</em> of sensory input explains the direction of fit of the corresponding predictions <span class="citation" data-cites="Clark15 FristonMattoutKilner11">(Clark 2016 p. 123; Friston et al. 2011)</span>. Sensory predictions regarding <em>proprioceptive</em> inputs play a special functional role – they have a desire-like direction of fit – because they are connected to motion-causing reflex arcs. There are no counterparts of these connections for other sensory channels – there are no muscular reflex arcs connected to the receptors for vision. Prediction errors for proprioception are thus uniquely wired to have behavioural consequences. This gives predictions for proprioceptive sensory inputs an inherently desire-like character.</p>
<p>While the presence of reflex arcs is a necessary feature of the proposed model of motor control, it is hard to see how it can explain the direction of fit of the ANN’s predictions. For sometimes proprioception is used, like vision, in a passive way to acquire sensory information – in such a case, proprioceptive prediction errors result in revisions to the model. When one puts one’s hands in one’s pocket to feel the shape of an unknown coin to determine whether it is a fifty-pence piece, one’s proprioceptive channels are used (primarily) to provide information to update one’s model. On the basis of proprioceptive prediction errors, one might adjust one’s predictive model to conclude that the coin inside one’s pocket is a pound coin, not a fifty-pence piece. In this case, predictions about proprioceptive inputs have a belief-like direction of fit. They are not used in a (vain) desire-like way to force the coin into the shape of a fifty-pence piece in order to make that prediction true. But if proprioceptive sensory inputs may be used in a passive fashion to revise the model, then it cannot be simply the proprioceptive nature of a sensory input that determines whether the associated predictions have a desire-like direction of fit.</p>
<p>The second suggestion – intended to complement the first – is that the degree of <em>precision weighting</em> of an error signal explains the direction of fit of its associated predictions <span class="citation" data-cites="BrownAdamsParees13 Clark15 Friston09 Hohwy13">(Brown et al. 2013; Clark 2016 pp. 215–6; Friston 2009 pp. 299–300; Hohwy 2013 p. 83)</span>. A high degree of precision weighting for a proprioceptive signal indicates that a prediction error is more ‘important’ than others for the computational system. Desire-like states should have a high degree of precision weighting in order to motivate the system to act on them, and to drown out other prediction errors that might drive behaviour. On this view, the graded distribution of precision weights across the ANN could been seen as reflecting a distribution of more or less belief-like and desire-like states across the system’s predictions.</p>
<p>While a high degree of precision weighting is again a necessary feature of the model, it is hard to see how that increased degree of precision weighting could determine direction of fit. For the <em>importance</em> of an error (how much the system should prioritise correcting for it relative to other errors), and <em>manner</em> that the system should go about correcting for it (changing the model or changing the world) seem to be two separate considerations that can, and often do, come apart. In principle, a cognitive agent might place supreme importance on correcting for a proprioceptive prediction error – it may believe that its future existence depends on it predicting what is in its pocket (‘Is it a piece of putty shaped as a cube or shaped as a ball?’). But no matter how highly it rates correcting for that error (e.g. gaining certainty that it is shaped like a cube), it is still an open question whether the system reduces that proprioceptive prediction error by revising the model or by changing the world. It might attempt to gain certainty about the shape of the putty by trying to estimate the current shape as accurately as possible or by forcing the putty into some arbitrary shape that it has chosen to predict. A proprioceptive prediction error – no matter what its degree of precision weighting – might be reduced in either way.</p>
<p>It is currently unclear how a predictive coding algorithm should encode direction of fit. <span class="citation" data-cites="FristonSchwartenbeckFitzGerald13">Friston et al. (2013)</span> suggest that one should ‘recode’ utilities (which have a desire-like fit) as probabilities.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn48" class="footnote-ref" id="fnref48" role="doc-noteref"><sup>48</sup></a> This would allow algorithms for decision making – including those that guide motor control – to be interpreted as a pure ‘inference’ over probabilities. All aspects of decision making could be viewed as instances of approximate Bayesian inference over a single type of formal state (over probabilities). Classical models of decision making tend to start from the assumption that decision making is a process that operates over two formally distinct states (credences and utilities). The objective of the process is typically characterised as that of maximising expected subjective utility. Bayesian inference counts as only one element in this process – that concerning belief fixation or belief update. It needs to be supplemented by, or embedded into, a larger account which explains how the credences arrived at by Bayesian inference are combined with utilities to generate action.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn49" class="footnote-ref" id="fnref49" role="doc-noteref"><sup>49</sup></a></p>
<p>While it is formally possible to recode utilities as probabilities, it is hard to see how it solves the problem described above. The cognitive system would still need to keep track of whether any particular probability so defined is a belief-like one (a credence) or a desire-like one (a recoded utility). The two have distinct functional roles within the cognitive economy of the agent and they differ in ways that go beyond any formal similarities. A cognitive agent might have a low credence in a specific outcome to which it also assigns a high utility (e.g. purchasing a winning lottery ticket); a high credence in an outcome to which it assigns a low utility (e.g. purchasing a losing lottery ticket); a high credence in an outcome to which it assigns high utility (e.g. purchasing a winning ticket to a lottery that it has secretly rigged); and a low credence in an outcome to which it assigns a low utility (e.g. purchasing a losing ticket to a lottery that it has secretly rigged). Regardless of how one formalises the relevant quantities (as probabilities or not), two independent degrees of freedom are needed to capture the difference between how the system thinks the world is and how it wishes the world to be. If both quantities are defined as probabilities, the system would need to traffic in two, materially distinct kinds of probability. But exactly how these two kinds of probability should be encoded in the numerical states of the ANN, and how the ANN should decide whether to minimise error via active inference (motor activity) or passive inference (belief revision) are unclear.</p>
<p>Explaining direction of fit may require a full algorithmic-level account of the high-level cognitive processes that lie between perception and motor control. One of the intended functions of these processes is to allow belief-like and desire-like states to combine in a rational way to produce action. These processes should take into account a wide, potentially unbounded, range of epistemic and pragmatic considerations to determine the most appropriate action given the context and whether that involves a motor response or a change to belief. However, a detailed algorithmic-level account of high-level central reasoning processes is exactly what ANN-based models currently do not provide.</p>
<h1 data-number="7" id="conclusion"><span class="header-section-number">7</span> Conclusion</h1>
<p>This paper has focused on what predictive coding says at Marr’s algorithmic level. The proposed algorithm consists in (i) a multi-layered, hierarchically structured artificial neural network; (ii) a repeated duplex arrangement of prediction and error units within each layer; (iii) each layer functioning so as to minimise prediction error about the state of the layer below. Numerical states of the network may be interpreted, in a further semantic step, as probabilistic representations and the manner in which they are transformed as a version of approximate Bayesian inference. The algorithm described in this paper is representative only of a deliberately simplified version of predictive coding. One should regard it as just a stepping stone on the way to a more elaborate proposal. However, it illustrates certain broad motifs – such as a hierarchically structured ANN, a functional structure of repeated prediction and error units – that one might expect to find in some future, more sophisticated algorithmic-level proposal.</p>
<p><span class="citation" data-cites="RaoBallard99">Rao &amp; Ballard (1999)</span> proposed that a hierarchical predictive coding algorithm should be used to model neural responses in the early visual system. Subsequently, the algorithm has been claimed to have much wider applications. In its boldest form, predictive coding claims that a hierarchical predictive coding algorithm governs <em>all</em> aspects of neural cognitive processing. During cognition – which according to predictive coding, aims to minimise sensory prediction error – the brain should be assumed to be implementing a giant, hierarchically structured ANN.</p>
<p>As with predictive coding’s computational-level proposal, it is natural to wonder what would happen if one were to trim the ambitions of predictive coding’s algorithmic-level claim. Perhaps the ANN describes some computational methods used by the brain, but not all. As we saw with the computational-level claim, the extent to which an advocate of predictive coding chooses to limit the scope of their claim will proportionately decrease the view’s coding entitlement to provide a grand, unifying theory of cognition. Nevertheless, even if it falls short of being a truly universal theory of all cognitive processes, if it were to accurately model <em>many</em> cognitive processes, or if it were to identify important <em>features</em> shared by aspects of cognition that are traditionally thought of as separate and unrelated (e.g. perception and motor control), it could still justify a claim to provide a unification at the algorithmic level, albeit not a version of unification that treats every cognitive process as an instance of the same algorithm.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fn50" class="footnote-ref" id="fnref50" role="doc-noteref"><sup>50</sup></a> Precisely how much of cognition the algorithm might unify, and the exact form that unification will take, is presently unclear.</p>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-AdamsShippFriston13" class="csl-entry" role="doc-biblioentry">
Adams, R. A., Shipp, S., &amp; Friston, K. (2013). <span>‘Predictions not commands: Active inference in the motor system’</span>, <em>Brain Structure &amp; Function</em>, 218: 611–43.
</div>
<div id="ref-Baker85" class="csl-entry" role="doc-biblioentry">
Baker, L. R. (1985). <span>‘A farewell to functionalism’</span>, <em>Philosophical Studies</em>, 48: 1–3.
</div>
<div id="ref-BechtelAbrahamsen02" class="csl-entry" role="doc-biblioentry">
Bechtel, W., &amp; Abrahamsen, A. (2002). <em>Connectionism and the mind: An introduction to parallel processing in networks</em>., 2nd ed. Oxford: Oxford University Press.
</div>
<div id="ref-Bishop06" class="csl-entry" role="doc-biblioentry">
Bishop, C. M. (2006). <em>Pattern recognition and machine learning</em>. New York, NY: Springer.
</div>
<div id="ref-BlalockOrtizFrankle20" class="csl-entry" role="doc-biblioentry">
Blalock, D., Ortiz, J. J. G., Frankle, J., &amp; Guttag, J. (2020). <em>What is the state of neural network pruning?</em>
</div>
<div id="ref-Bogacz17" class="csl-entry" role="doc-biblioentry">
Bogacz, R. (2017). <span>‘A tutorial on the free-energy framework for modelling perception and learning’</span>, <em>Journal of Mathematical Psychology</em>, 76/198–211.
</div>
<div id="ref-BrownAdamsParees13" class="csl-entry" role="doc-biblioentry">
Brown, H., Adams, R. A., Parees, I., Edwards, M., &amp; Friston, K. (2013). <span>‘Active inference, sensory attenuation and illusions’</span>, <em>Cognitive Processing</em>, 14: 411–27.
</div>
<div id="ref-CisekKalaska10" class="csl-entry" role="doc-biblioentry">
Cisek, P., &amp; Kalaska, J. F. (2010). <span>‘Neural mechanisms for interacting with a world full of action choices’</span>, <em>Annual Review of Neuroscience</em>, 33: 269–98.
</div>
<div id="ref-Clark13" class="csl-entry" role="doc-biblioentry">
Clark, A. (2013). <span>‘Whatever next? Predictive brains, situated agents, and the future of cognitive science’</span>, <em>Behavioral and Brain Sciences</em>, 36: 181–253.
</div>
<div id="ref-Clark14" class="csl-entry" role="doc-biblioentry">
——. (2014). <em>Mindware: An introduction to cognitive science</em>., 2nd ed. Oxford: Oxford University Press.
</div>
<div id="ref-Clark15" class="csl-entry" role="doc-biblioentry">
——. (2016). <em>Surfing uncertainty: Prediction, action, and the embodied mind</em>. Oxford: Oxford University Press.
</div>
<div id="ref-ColomboElkin18" class="csl-entry" role="doc-biblioentry">
Colombo, M., Elkin, L., &amp; Hartmann, S. (2018). <span>‘Being realist about <span>B</span>ayes, and the predictive processing theory of mind’</span>, <em>The British Journal for the Philosophy of Science</em>. DOI: <a href="https://doi.org/10.1093/bjps/axy059">10.1093/bjps/axy059</a>
</div>
<div id="ref-ColomboSeries12" class="csl-entry" role="doc-biblioentry">
Colombo, M., &amp; Seriès, P. (2012). <span>‘Bayes on the brain—on <span>B</span>ayesian modelling in neuroscience’</span>, <em>The British Journal for the Philosophy of Science</em>, 63: 697–723.
</div>
<div id="ref-Danks14" class="csl-entry" role="doc-biblioentry">
Danks, D. (2014). <em>Unifying the mind: Cognitive representations as graphical models</em>. Cambridge, MA: MIT Press.
</div>
<div id="ref-Dennett87c" class="csl-entry" role="doc-biblioentry">
Dennett, D. C. (1987). <span>‘Three kinds of intentional psychology’</span>. <em>The intentional stance</em>. MIT Press: Cambridge, MA.
</div>
<div id="ref-FeldmanFriston10" class="csl-entry" role="doc-biblioentry">
Feldman, H., &amp; Friston, K. (2010). <span>‘Attention, uncertainty, and free-energy’</span>, <em>Frontiers in Human Neuroscience</em>, 4: 1–23.
</div>
<div id="ref-FitzGeraldDolan14" class="csl-entry" role="doc-biblioentry">
FitzGerald, T., Dolan, R. J., &amp; Friston, K. (2014). <span>‘Model averaging, optimal inference, and habit formation’</span>, <em>Frontiers in Human Neuroscience</em>, 8: 1–1.
</div>
<div id="ref-Friston03" class="csl-entry" role="doc-biblioentry">
Friston, K. (2003). <span>‘Learning and inference in the brain’</span>, <em>Neural Networks</em>, 16: 1325–52.
</div>
<div id="ref-Friston05" class="csl-entry" role="doc-biblioentry">
——. (2005). <span>‘A theory of cortical responses’</span>, <em>Philosophical Transactions of the Royal Society of London, Series B</em>, 360: 815–36.
</div>
<div id="ref-Friston08" class="csl-entry" role="doc-biblioentry">
——. (2008). <span>‘Hierarchical models in the brain’</span>, <em><span>PLoS</span> Computational Biology</em>, 4: e1000211.
</div>
<div id="ref-Friston09" class="csl-entry" role="doc-biblioentry">
——. (2009). <span>‘The free-energy principle: A rough guide to the brain?’</span>, <em>Trends in Cognitive Sciences</em>, 13: 293–301.
</div>
<div id="ref-Friston10" class="csl-entry" role="doc-biblioentry">
——. (2010). <span>‘The free-energy principle: A unified brain theory?’</span>, <em>Nature Reviews Neuroscience</em>, 11: 127–38.
</div>
<div id="ref-FristonFitzGeraldRigoli17" class="csl-entry" role="doc-biblioentry">
Friston, K., FitzGerald, T., Rigoli, F., Schwartenbeck, P., &amp; Pezzulo, G. (2017). <span>‘Active inference: A process theory’</span>, <em>Neural Computation</em>, 29: 1–49.
</div>
<div id="ref-FristonKilner06" class="csl-entry" role="doc-biblioentry">
Friston, K., Kilner, J., &amp; Harrison, L. (2006). <span>‘A free energy principle for the brain’</span>, <em>Journal of Physiology (Paris)</em>, 100: 70–87.
</div>
<div id="ref-FristonMattoutKilner11" class="csl-entry" role="doc-biblioentry">
Friston, K., Mattout, J., &amp; Kilner, J. (2011). <span>‘Action understanding and active inference’</span>, <em>Biological Cybernetics</em>, 104: 137–60.
</div>
<div id="ref-FristonParrVries17" class="csl-entry" role="doc-biblioentry">
Friston, K., Parr, T., &amp; Vries, B. de. (2017). <span>‘The graphical brain: <span>B</span>elief propagation and active inference’</span>, <em>Network Neuroscience</em>, 1: 381–414.
</div>
<div id="ref-FristonSchwartenbeckFitzGerald13" class="csl-entry" role="doc-biblioentry">
Friston, K., Schwartenbeck, P., FitzGerald, T., Moutoussis, M., Behrens, T., &amp; Dolan, R. J. (2013). <span>‘The anatomy of choice: Active inference and agency’</span>, <em>Frontiers in Human Neuroscience</em>, 7: 598.
</div>
<div id="ref-FristonStephan07" class="csl-entry" role="doc-biblioentry">
Friston, K., &amp; Stephan, K. E. (2007). <span>‘Free-energy and the brain’</span>, <em>Synthese</em>, 159: 417–58.
</div>
<div id="ref-GelmanHill07" class="csl-entry" role="doc-biblioentry">
Gelman, A., &amp; Hill, J. (2007). <em>Data analysis using regression and multilevel/hierarchical models</em>. Cambridge: Cambridge University Press.
</div>
<div id="ref-Harpur97" class="csl-entry" role="doc-biblioentry">
Harpur, G. F. (1997). <em>Low entropy coding with unsupervised neural networks</em> (PhD thesis). University of Cambridge.
</div>
<div id="ref-Haugeland81" class="csl-entry" role="doc-biblioentry">
Haugeland, J. (1981). <span>‘Semantic engines: An introduction to mind design’</span>. Haugeland J. (ed.) <em>Mind design</em>, pp. 1–34. MIT Press: Cambridge, MA.
</div>
<div id="ref-Henriksen20" class="csl-entry" role="doc-biblioentry">
Henriksen, M. (2020). <span>‘Variational free energy and economics optimizing with biases and bounded rationality’</span>, <em>Frontiers in Psychology</em>, 11/549187.
</div>
<div id="ref-HintonSejnowski83" class="csl-entry" role="doc-biblioentry">
Hinton, G. E., &amp; Sejnowski, T. J. (1983). <span>‘Optimal perceptual inference’</span>, <em>Proceedings of the <span>IEEE</span> conference on Computer Vision and Pattern Recognition</em>, 448.
</div>
<div id="ref-Hinton86" class="csl-entry" role="doc-biblioentry">
——. (1986). <span>‘Learning and relearning in <span>B</span>oltzmann machines’</span>. Rumelhart D. E., McClelland J., &amp; PDP Research Group the (eds) <em>Parallel distributed processing: Explorations in the microstructure of cognition</em>, Vol. 1, pp. 282–317. MIT Press: Cambridge, MA.
</div>
<div id="ref-HochsteinAhissar02" class="csl-entry" role="doc-biblioentry">
Hochstein, S., &amp; Ahissar, M. (2002). <span>‘View from the top: Hierarchies and reverse hierarchies in the visual system’</span>, <em>Neuron</em>, 36: 791–804.
</div>
<div id="ref-Hohwy12" class="csl-entry" role="doc-biblioentry">
Hohwy, J. (2012). <span>‘Attention and conscious perception in the hypothesis testing brain’</span>, <em>Frontiers in Psychology</em>, 3: 1–4.
</div>
<div id="ref-Hohwy13" class="csl-entry" role="doc-biblioentry">
——. (2013). <em>The predictive mind</em>. Oxford: Oxford University Press.
</div>
<div id="ref-JonesLove11" class="csl-entry" role="doc-biblioentry">
Jones, M., &amp; Love, B. C. (2011). <span>‘Bayesian fundamentalism or enlightenment? On the explanatory status and theoretical contributions of <span>B</span>ayesian models of cognition’</span>, <em>Behavioral and Brain Sciences</em>, 34: 169–231.
</div>
<div id="ref-KadarBenShahar12" class="csl-entry" role="doc-biblioentry">
Kadar, I., &amp; Ben-Shahar, O. (2012). <span>‘A perceptual paradigm and psychophysical evidence for hierarchy in scene gist processing’</span>, <em>Journal of Vision</em>, 12: 1–7.
</div>
<div id="ref-KanaiKomuraShipp15" class="csl-entry" role="doc-biblioentry">
Kanai, R., Komura, Y., Shipp, S., &amp; Friston, K. (2015). <span>‘Cerebral hierarchies: Predictive processing, precision and the pulvinar’</span>, <em>Philosophical Transactions of the Royal Society of London, Series B</em>, 370: 20140169.
</div>
<div id="ref-Klein18" class="csl-entry" role="doc-biblioentry">
Klein, C. (2018). <span>‘What do predictive coders want?’</span>, <em>Synthese</em>, 195: 2541–57.
</div>
<div id="ref-KrotovHopfield19" class="csl-entry" role="doc-biblioentry">
Krotov, D., &amp; Hopfield, J. J. (2019). <span>‘Unsupervised learning by competing hidden units’</span>, <em>Proceedings of the National Academy of Sciences</em>, 116: 7723–31.
</div>
<div id="ref-LeCunBengioHinton15" class="csl-entry" role="doc-biblioentry">
LeCun, Y., Bengio, Y., &amp; Hinton, G. E. (2015). <span>‘Deep learning’</span>, <em>Nature</em>, 521: 436–44.
</div>
<div id="ref-LeeMumford03" class="csl-entry" role="doc-biblioentry">
Lee, T. S., &amp; Mumford, D. (2003). <span>‘Hierarchical <span>B</span>ayesian inference in the visual cortex’</span>, <em>Journal of the Optical Society of America</em>, 20: 1434–48.
</div>
<div id="ref-MacKay03" class="csl-entry" role="doc-biblioentry">
MacKay, D. J. C. (2003). <em>Information theory, inference, and learning algorithms</em>. Cambridge: Cambridge University Press.
</div>
<div id="ref-MaloneyMamassian09" class="csl-entry" role="doc-biblioentry">
Maloney, L. T., &amp; Mamassian, P. (2009). <span>‘Bayesian decision theory as a model of human visual perception: Testing <span>B</span>ayesian transfer’</span>, <em>Visual Neuroscience</em>, 26: 147–55.
</div>
<div id="ref-McClelland98" class="csl-entry" role="doc-biblioentry">
McClelland, J. L. (1998). <span>‘Connectionist models of <span>B</span>ayesian infererence’</span>. Oaksford M. &amp; Chater N. (eds) <em>Rational models of cognition</em>, pp. 21–53. Oxford University Press.
</div>
<div id="ref-McClelland13" class="csl-entry" role="doc-biblioentry">
——. (2013). <span>‘Integrating probabilistic models of perception and interactive neural networks: A historical and tutorial review’</span>, <em>Frontiers in Psychology</em>, 4: 503.
</div>
<div id="ref-Mumford92" class="csl-entry" role="doc-biblioentry">
Mumford, D. (1992). <span>‘On the computational architecture of the neocortex: <span>II</span> the role of cortico-cortico loops’</span>, <em>Biological Cybernetics</em>, 66: 241–51.
</div>
<div id="ref-ParrMarkovicKiebel19" class="csl-entry" role="doc-biblioentry">
Parr, T., Markovic, D., Kiebel, S. J., &amp; Friston, K. (2019). <span>‘Neuronal message passing using mean-field, <span>B</span>ethe, and marginal approximations’</span>, <em>Scientific Reports</em>, 9: 1889.
</div>
<div id="ref-RaoBallard99" class="csl-entry" role="doc-biblioentry">
Rao, R. P. N., &amp; Ballard, D. H. (1999). <span>‘Predictive coding in the visual cortex: A functional interpretation of some extra-classical receptive-field effects’</span>, <em>Nature Neuroscience</em>, 2: 79–87.
</div>
<div id="ref-Rescorla15" class="csl-entry" role="doc-biblioentry">
Rescorla, M. (2016). <span>‘Bayesian sensorimotor psychology’</span>, <em>Mind and Language</em>, 31: 3–6.
</div>
<div id="ref-RoskiesWood17" class="csl-entry" role="doc-biblioentry">
Roskies, A. L., &amp; Wood, C. C. (2017). <span>‘Catching the prediction wave in brain science’</span>, <em>Analysis</em>, 77: 848–57.
</div>
<div id="ref-RussellNorvig10" class="csl-entry" role="doc-biblioentry">
Russell, S., &amp; Norvig, P. (2010). <em>Artificial intelligence: A modern approach</em>., 3rd ed. Upper Saddle River, NJ: Pearson.
</div>
<div id="ref-Shea13a" class="csl-entry" role="doc-biblioentry">
Shea, N. (2013). <span>‘Perception versus action: <span>T</span>he computations may be the same but the direction of fit differs’</span>, <em>Behavioral and Brain Sciences</em>, 36: 228–9.
</div>
<div id="ref-Spratling17" class="csl-entry" role="doc-biblioentry">
Spratling, M. W. (2017). <span>‘A review of predictive coding algorithms’</span>, <em>Brain and Cognition</em>, 112: 92–7.
</div>
<div id="ref-Sprevak20d" class="csl-entry" role="doc-biblioentry">
Sprevak, M. (forthcoming). <span>‘Predictive coding <span>IV</span>: The implementation level’</span>, <em>TBC</em>.
</div>
<div id="ref-Sprevak20b" class="csl-entry" role="doc-biblioentry">
——. (forthcoming). <span>‘Predictive coding <span>II</span>: The computational level’</span>, <em>TBC</em>.
</div>
<div id="ref-Sprevak20a" class="csl-entry" role="doc-biblioentry">
——. (forthcoming). <span>‘Predictive coding <span>I</span>: introduction’</span>, <em>TBC</em>.
</div>
<div id="ref-Williams18" class="csl-entry" role="doc-biblioentry">
Williams, D. (2018). <span>‘Predictive coding and thought’</span>, <em>Synthese</em>. DOI: <a href="https://doi.org/10.1007/s11229-018-1768-x">10.1007/s11229-018-1768-x</a>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><span class="citation" data-cites="MaloneyMamassian09">Maloney &amp; Mamassian (2009)</span> describe how table lookup can produce similar results to Bayesian inference.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>My account of predictive coding’s algorithm is based on those of <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span>; <span class="citation" data-cites="Friston05">Friston (2005)</span>; <span class="citation" data-cites="RaoBallard99">Rao &amp; Ballard (1999)</span>; <span class="citation" data-cites="Spratling17">Spratling (2017)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>See the discussion of formal versus informal computational-level descriptions in <span class="citation" data-cites="Sprevak20b">Sprevak (forthcoming)</span>, Section 3.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>For proposals about how the <span class="math inline">\(x_i\)</span> map onto physical activities in the brain, see <span class="citation" data-cites="Sprevak20d">Sprevak (forthcoming)</span>, Section 4.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>The <span class="math inline">\(\mathbf{y}\)</span> values are sometimes called ‘coefficients’ of the model.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>The <span class="math inline">\(\mathbf{e}\)</span> vector is also known as the ‘residual error’.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>This is equivalent to optimising for minimal mean-squared error, <span class="math inline">\(\sum_i (x_i - r_i)^2/m\)</span>, see <span class="citation" data-cites="Sprevak20a">Sprevak (forthcoming)</span>, Section 4.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>For an introduction to artificial neural networks, see <span class="citation" data-cites="BechtelAbrahamsen02">Bechtel &amp; Abrahamsen (2002)</span>; <span class="citation" data-cites="Clark14">Clark (2014)</span>, Ch. 4.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Real neurons are highly non-linear. They change their response profile to issue a spike if input activation breaches a certain threshold. This is followed by a refractory period when they yield little or no output irrespective of their input.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Error units are governed by an activation function of the same kind, i.e. <span class="math inline">\(e_i = \sum_j - w_{i, j} y_j\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>See <span class="citation" data-cites="Harpur97">Harpur (1997)</span>, Section 4.2. The proof involves showing that the described ANN would perform a version of minimisation by gradient descent on the prediction-error value.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>For example, see <span class="citation" data-cites="Friston05">Friston (2005)</span>, pp. 815, 821.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>See <span class="citation" data-cites="Harpur97">Harpur (1997)</span>, Section 4.7. The proof again involves showing the ANN would perform a version of gradient descent on its prediction-error value – this time gradient descent over the space of possible connection weights, rather than over the space of possible activation values.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>Backpropagation rules are commonly used to train systems in supervised learning; Hebbian learning rules are generally seen as better suited to model unsupervised forms of learning <span class="citation" data-cites="KrotovHopfield19">(Krotov &amp; Hopfield 2019)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>Equivalently: it allows certain prediction values or model parameters to held more ‘confidently’ by the system than others because they are less likely to be changed by activity flowing into their corresponding error units.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>The inverse of the <span class="math inline">\(\boldsymbol{\Sigma}\)</span> matrix is sometimes called the ‘covariance matrix’.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>See <span class="citation" data-cites="Clark15">Clark (2016)</span>, pp. 146–151; <span class="citation" data-cites="Friston03">Friston (2003)</span>, p. 1345.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>An additional puzzle is how shifts in attention could be under volitional control if changes to <span class="math inline">\(\boldsymbol{\Sigma}\)</span> are determined by the rules of Hebbian learning.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Half the <span class="math inline">\(n \times m\)</span> elements of <span class="math inline">\(\mathbf{W}\)</span> are fixed because of the assumption made about reciprocal connections between prediction and error units, <span class="math inline">\(w_{i, j} = - w_{j, i}\)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p><span class="citation" data-cites="Friston05">Friston (2005)</span>, p. 823; <span class="citation" data-cites="Friston09">Friston (2009)</span>, Box 3 on p. 297.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>This would be a form of Bayesian model selection.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>Note that Bayesian conditionalisation introduces a ‘bias’ towards simpler, more constrained models. Models with fewer parameters will effectively receive a bonus during Bayesian conditionalisation – a higher probability in the agent’s posterior distribution – even if the agent was indifferent between those models before. Roughly speaking, this is because a model that makes no assumptions about the specific value of some additional parameter should, everything else being equal, be assigned more subjective probability than one that makes exactly the same assumptions <em>and</em> an extra assumption about that additional parameter’s specific value. Bayesian model comparison (and model averaging) will thus tend to drive an agent towards models with fewer free parameters. <span class="citation" data-cites="MacKay03">(See MacKay 2003 pp. 343–51 for a full explanation of how this Bayesian “Occam’s razor” works.)</span> <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> argue that this feature provides an explanation of how predictive coding can allow the brain to optimise for both <em>simplicity</em> as well as predictive <em>accuracy</em> of its generative model <span class="citation" data-cites="Sprevak20a">(c.f. Sprevak forthcoming sec. 2)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p><span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span> claim that the computational task of Bayesian model averaging also entails minimising variational free energy, and hence (granted certain additional assumptions) minimising sensory prediction error. Therefore, like inference and learning, Bayesian model averaging falls under predictive coding’s single computational-level task description of minimising sensory prediction error (pp. 2–3, Appendix A3–A5). See <span class="citation" data-cites="FristonStephan07">Friston &amp; Stephan (2007)</span>, pp. 434–435.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p>See the brief discussion of this in <span class="citation" data-cites="FitzGeraldDolan14">FitzGerald et al. (2014)</span>, Appendix A5.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn25" role="doc-endnote"><p>For a survey, see <span class="citation" data-cites="BlalockOrtizFrankle20">Blalock et al. (2020)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn26" role="doc-endnote"><p><span class="citation" data-cites="Friston05">Friston (2005)</span>, pp. 822–823; <span class="citation" data-cites="Friston10">Friston (2010)</span>, p. 132; <span class="citation" data-cites="RaoBallard99">Rao &amp; Ballard (1999)</span>, p. 86; <span class="citation" data-cites="Spratling17">Spratling (2017)</span>, pp. 93–94.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn27" role="doc-endnote"><p>See discussion of this point in <span class="citation" data-cites="Friston05">Friston (2005)</span>, p. 823; <span class="citation" data-cites="Friston10">Friston (2010)</span>, p. 130; <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span>, pp. 199, 209. <span class="citation" data-cites="Spratling17">Spratling (2017)</span> raises doubts about neural plausibility of the version of the predictive coding algorithm described here as it assumes prediction and error units can take negative values as activation levels (pp. 94–95).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn28" role="doc-endnote"><p>See <span class="citation" data-cites="GelmanHill07">Gelman &amp; Hill (2007)</span>, pp. 3–8 for discussion of the benefits of using hierarchical models for prediction. See <span class="citation" data-cites="Mumford92">Mumford (1992)</span> for an informal description of a hierarchical form of predictive coding in which the brain tries to match pattern-recognition ‘templates’ at various levels in its processing. <span class="citation" data-cites="LeeMumford03">Lee &amp; Mumford (2003)</span> give a more detailed hierarchical Bayesian version of the model for the visual system, albeit one that uses a different algorithm for inference (particle filtering) to that typically associated with predictive coding (variational inference using message passing).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn29" role="doc-endnote"><p><span class="citation" data-cites="HochsteinAhissar02">Hochstein &amp; Ahissar (2002)</span>; <span class="citation" data-cites="KadarBenShahar12">Kadar &amp; Ben-Shahar (2012)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn30" role="doc-endnote"><p>See also <span class="citation" data-cites="FristonKilner06">Friston et al. (2006)</span>, p. 70.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn31" role="doc-endnote"><p>Building a hierarchical model of the world is <em>one</em> strategy to achieve accurate predictions. This is not to say that a predictive model that fails to encode the true hierarchical (causal or other) relationships between hidden features in the world might not be good enough at prediction for many practical purposes. See <span class="citation" data-cites="CisekKalaska10">Cisek &amp; Kalaska (2010)</span> on the benefits of simple, ‘pragmatic’ representations and <span class="citation" data-cites="Clark15">Clark (2016)</span>, Ch. 8 on ‘frugal’ forms of prediction.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn32" role="doc-endnote"><p>See the results of simulations run by <span class="citation" data-cites="RaoBallard99">Rao &amp; Ballard (1999)</span>, p. 84.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn33" role="doc-endnote"><p>See <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span>, p. 201; <span class="citation" data-cites="Friston03">Friston (2003)</span>, pp. 1343; <span class="citation" data-cites="Friston05">Friston (2005)</span>, p. 821; <span class="citation" data-cites="Spratling17">Spratling (2017)</span>, p. 94.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn34" role="doc-endnote"><p>See <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span>, pp. 202, 204–208.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn35" role="doc-endnote"><p><span class="citation" data-cites="Mumford92">Mumford (1992)</span> describes how the brain strives to match incoming sensory stimulation – to inhibit the sensory neurons to the right degree to counteract the excitatory stimulation they receive from the outside world. A ‘perfect’ prediction means that the relevant sensory neurons would be silent (p. 247).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn36" role="doc-endnote"><p><span class="citation" data-cites="Hohwy13">Hohwy (2013)</span> gives a wonderful illustration of a representation-light reading of the predictive coding algorithm by describing a Rube Goldberg-esque machine that ‘predicts’ – without in any obvious fashion using representations – leaks in a water dam by progressively moving a hierarchy of arms, cogs, wheels to insert plugs into spots where leaks have tended to appear (pp. 62–63).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn37" role="doc-endnote"><p>See <span class="citation" data-cites="Baker85">Baker (1985)</span>, pp. 6–7.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn38" role="doc-endnote"><p>The notion that numerical activation values and connection weights inside an ANN can be interpreted as subjective probabilities and the rules of the ANN as entailing that the network performs some form of Bayesian (or some other kind of) probabilistic inference is not new. For discussion of the employment of ANNs as probabilistic inference engines, see <span class="citation" data-cites="HintonSejnowski83">Hinton &amp; Sejnowski (1983)</span>; <span class="citation" data-cites="Hinton86">Hinton &amp; Sejnowski (1986)</span>; <span class="citation" data-cites="MacKay03">MacKay (2003)</span>, Ch. 41; <span class="citation" data-cites="McClelland98">McClelland (1998)</span>; <span class="citation" data-cites="McClelland13">McClelland (2013)</span>. For discussion of the general idea of algorithms as ways to automate semantic inference – automatic formal systems as ‘semantic engines’ – see <span class="citation" data-cites="Dennett87c">Dennett (1987)</span>; <span class="citation" data-cites="Haugeland81">Haugeland (1981)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn39" role="doc-endnote"><p>See <span class="citation" data-cites="Bogacz17">Bogacz (2017)</span>, pp. 199–202; <span class="citation" data-cites="Friston05">Friston (2005)</span>, 821–822 for worked examples.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40" role="doc-endnote"><p>For a general introduction to message-passing forms of probabilistic inference and graphical probabilistic models and, see <span class="citation" data-cites="Bishop06">Bishop (2006)</span>, Ch. 8; <span class="citation" data-cites="MacKay03">MacKay (2003)</span>, Chs. 16, 26; <span class="citation" data-cites="RussellNorvig10">Russell &amp; Norvig (2010)</span>, Ch. 16.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref40" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn41" role="doc-endnote"><p>See <span class="citation" data-cites="ColomboSeries12">Colombo &amp; Seriès (2012)</span>; <span class="citation" data-cites="ColomboElkin18">Colombo et al. (2018)</span>; <span class="citation" data-cites="JonesLove11">Jones &amp; Love (2011)</span>; <span class="citation" data-cites="Rescorla15">Rescorla (2016)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn42" role="doc-endnote"><p><span class="citation" data-cites="Clark15">Clark (2016)</span>, Ch. 8 suggests that the brain uses a diverse range of computational methods to minimise its sensory prediction error, including ‘quicker, dirtier, more “embodied”’ strategies than the hierarchical algorithm described above (p. 268). He does suggest, however, that the hierarchical ANN is not simply one technique among others, but that it plays a special, structuring role in training, coordinating, and recruiting all the other processes (pp. 252–260).<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43" role="doc-endnote"><p>For discussion of challenges in dealing with modelling these cases, see <span class="citation" data-cites="Clark15">Clark (2016)</span>, pp. 299–300; <span class="citation" data-cites="RoskiesWood17">Roskies &amp; Wood (2017)</span>; <span class="citation" data-cites="Williams18">Williams (2018)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn44" role="doc-endnote"><p>Given that the single ANN attempts to minimise sensory prediction error averaged across all sensory channels, one should expect that inside the ANN many prediction values (unit activation levels) and generative model parameters (connection weights) will have a multi-modal character. Advocates of predictive coding suggest that even at early stages within the sensory periphery, one should expect multi-modal processing in the brain <span class="citation" data-cites="Clark15">(see Clark 2016 p. 121)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn45" role="doc-endnote"><p>See <span class="citation" data-cites="AdamsShippFriston13">Adams et al. (2013)</span> for the model. See <span class="citation" data-cites="Clark15">Clark (2016)</span>, Ch. 4 for a helpful informal summary. <span class="citation" data-cites="FristonFitzGeraldRigoli17">Friston, FitzGerald, et al. (2017)</span> give a worked example that simulates a range of neural responses.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref45" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn46" role="doc-endnote"><p>See <span class="citation" data-cites="RussellNorvig10">Russell &amp; Norvig (2010)</span>, pp. 50–54.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn47" role="doc-endnote"><p>For further discussion of this and associated problems, see <span class="citation" data-cites="Klein18">Klein (2018)</span>; <span class="citation" data-cites="Shea13a">Shea (2013)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn48" role="doc-endnote"><p>More precisely, utilities should be encoded as log likelihoods. The utility of an outcome given a predictive model, <span class="math inline">\(U(o \mid m)\)</span>, should be represented by the log of some prior probability of the outcome conditional on the model, <span class="math inline">\(\ln P(o \mid m)\)</span>. Encoding utilities as log probabilities preserves the structure of the agent’s utility function, and so can preserve the underlying logic of decision making <span class="citation" data-cites="Henriksen20">(see Henriksen 2020)</span>.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref48" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn49" role="doc-endnote"><p>For a summary of classical approaches to decision making, see <span class="citation" data-cites="RussellNorvig10">Russell &amp; Norvig (2010)</span>, Ch. 16.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref49" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn50" role="doc-endnote"><p>See discussion in <span class="citation" data-cites="Clark13">Clark (2013)</span>, p. 200; <span class="citation" data-cites="Clark15">Clark (2016)</span>, pp. 297–300, and versions of qualified unification that an algorithmic-level model might provide discussed in <span class="citation" data-cites="Danks14">Danks (2014)</span>, pp. 175–204.<a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#fnref50" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div>

                            </div>
                            
                        </div>

                    </div>

                    <div class="is-col is-33">     
                        <div class="is-hidden-print is-hidden-mobile is-sticky">
                            
                                <h1 style="margin-top: 0px;">Contents</h1>
                                <ul class="is-unstyled">
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#introduction"><span style="visibility: visible;">1</span> &nbsp;  Introduction</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#predictive-coding-in-one-layer"><span style="visibility: visible;">2</span> &nbsp;  Predictive coding in one layer</a>
            
        </span>
        
    </li>
    
    <li>
        
        <ul class="is-unstyled" style="margin-left: 15px;">
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-computational-task"><span style="visibility: visible;">2.1</span> &nbsp;  The computational task</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-inference-algorithm"><span style="visibility: visible;">2.2</span> &nbsp;  The inference algorithm</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#the-learning-algorithm"><span style="visibility: visible;">2.3</span> &nbsp;  The learning algorithm</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#precision-weighting"><span style="visibility: visible;">2.4</span> &nbsp;  Precision weighting</a>
                    
                </span>
            </li>
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#extending-the-algorithm"><span style="visibility: visible;">2.5</span> &nbsp;  Extending the algorithm</a>
                    
                </span>
            </li>
            
        </ul>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#an-algorithm-not-an-implementation"><span style="visibility: visible;">3</span> &nbsp;  An algorithm, not an implementation</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#hierarchical-structure"><span style="visibility: visible;">4</span> &nbsp;  Hierarchical structure</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#representing-probabilistic-guesses"><span style="visibility: visible;">5</span> &nbsp;  Representing probabilistic guesses</a>
            
        </span>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#going-beyond-perception"><span style="visibility: visible;">6</span> &nbsp;  Going beyond perception</a>
            
        </span>
        
    </li>
    
    <li>
        
        <ul class="is-unstyled" style="margin-left: 15px;">
            
            <li>
                <span style="font-size: 12px;">
                    
                    <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#example-of-motor-control"><span style="visibility: visible;">6.1</span> &nbsp;  Example of motor control</a>
                    
                </span>
            </li>
            
        </ul>
        
    </li>
    
    <li>
        
        <span style="font-size: 14px;">
            
            <a href="https://marksprevak.com/publications/predictive-coding-iii-the-algorithmic-level-4cf4/#conclusion"><span style="visibility: visible;">7</span> &nbsp;  Conclusion</a>
            
        </span>
        
    </li>
    
</ul>

                            
                            
                        </div>
                    </div>
                </div>
            </main>

        <footer class="footer"></footer>

        </div>

        <script src="https://marksprevak.com/kube/js/kube.min.js"></script>
<script>
    $K.init();
</script>


    </body>
</html>
